<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMX Studio - Enhanced</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
/* Custom Styles for JMX Studio */

body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif; 
}

.tab-active { 
    border-bottom: 2px solid #000; 
    font-weight: 600; 
}

.status-enabled { 
    background-color: #dcfce7; 
    color: #166534; 
    border: 1px solid #bbf7d0; 
}

.status-disabled { 
    background-color: #fee2e2; 
    color: #991b1b; 
    border: 1px solid #fecaca; 
}

.metric-card { 
    padding: 1rem; 
    border-radius: 0.5rem; 
    border: 1px solid #e5e7eb; 
    background-color: #f9fafb; 
}

.input-field { 
    border: 1px solid #d1d5db; 
    border-radius: 0.375rem; 
    padding: 0.5rem 0.75rem; 
}

.input-field:focus { 
    outline: none; 
    border-color: #000; 
    box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.1); 
}

.warning-box { 
    background-color: #fef3c7; 
    border-left: 4px solid #f59e0b; 
    padding: 1rem; 
    border-radius: 0.5rem; 
}

/* Tab content animation */
.tab-content {
    animation: fadeIn 0.3s ease-in-out;
}

@keyframes fadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Custom scrollbar */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
    background: #888;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #555;
}

/* Loading spinner */
.spinner {
    border: 3px solid #f3f3f3;
    border-top: 3px solid #000;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

</style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white border-b border-gray-200 sticky top-0 z-50 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 py-4">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-2xl font-bold text-gray-900">JMX Studio</h1>
                    <p class="text-sm text-gray-600">Unified JMeter 5.6.3 Configuration Tool</p>
                </div>
                <div class="flex items-center gap-4">
                    <div id="modeIndicator" class="hidden px-4 py-2 bg-gray-900 text-white rounded-lg text-sm font-semibold">
                        <span class="text-gray-400 mr-2">Mode:</span>
                        <span id="currentMode">Iteration</span>
                    </div>
                    <span class="text-xs text-gray-500">v4.0.0</span>
                    <div class="flex items-center gap-2">
                        <div id="statusDot" class="w-2 h-2 bg-green-500 rounded-full animate-pulse" title="Online"></div>
                        <span id="statusText" class="text-xs font-medium text-green-600">Ready</span>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 py-6 pb-20">
        <!-- File Upload Section -->
        <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6 mb-6">
            <div class="flex items-center justify-between gap-4">
                <div class="flex-1">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Upload JMX File</label>
                    <input type="file" id="fileInput" accept=".jmx,.xml,text/xml,application/xml" 
                           class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none file:mr-4 file:py-2 file:px-4 file:rounded-l-lg file:border-0 file:bg-black file:text-white hover:file:bg-gray-800"
                           aria-label="Choose JMX file to upload">
                </div>
                <button id="downloadBtn" disabled onclick="downloadJMX()" 
                        class="mt-6 px-6 py-2 bg-black text-white rounded-lg hover:bg-gray-800 transition-colors disabled:bg-gray-300 disabled:cursor-not-allowed">
                    üíæ Download
                </button>
            </div>
        </div>

        <!-- Upload Prompt -->
        <div id="uploadPrompt" class="bg-white rounded-lg shadow-sm border border-gray-200 p-12 text-center">
            <svg class="w-16 h-16 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
            </svg>
            <h3 class="text-xl font-semibold text-gray-700 mb-2">Upload JMX File to Begin</h3>
            <p class="text-gray-500">Select a JMeter test plan to configure samplers, variables, CSV data, timers, and workload</p>
        </div>

        <!-- Main Content Tabs -->
        <div id="mainContent" style="display: none;">
            <!-- Tab Navigation -->
            <div class="mb-6 border-b border-gray-200">
                <nav class="flex gap-8">
                    <button onclick="switchTab('master')" id="tab-master" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900 tab-active">Master Control</button>
                    <button onclick="switchTab('samplers')" id="tab-samplers" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Samplers</button>
                    <button onclick="switchTab('variables')" id="tab-variables" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Variables</button>
                    <button onclick="switchTab('csv')" id="tab-csv" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">CSV Data</button>
                    <button onclick="switchTab('timers')" id="tab-timers" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Timers</button>
                    <button onclick="switchTab('workload')" id="tab-workload" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Workload Calc</button>
                    <button onclick="switchTab('threadgroups')" id="tab-threadgroups" class="pb-3 px-1 text-sm font-medium text-gray-700 hover:text-gray-900">Thread Groups</button>
                </nav>
            </div>

            <!-- Tab Content Areas -->
            <div id="content-master" class="tab-content">
                <!-- Master Scenario Scaling -->
                <div class="bg-white rounded-lg shadow-sm border-2 border-black p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-2">üéØ Master Scenario Scaling</h3>
                    <p class="text-sm text-gray-600 mb-4">Scale entire scenario - affects ALL thread groups and TPS</p>
                    <div class="flex items-center gap-4 mb-4">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Scale Percentage</label>
                            <input type="number" id="masterScale" value="100" min="1" max="1000" step="1" 
                                onchange="updatePerformanceSummary()"
                                class="w-32 px-3 py-2 border border-gray-300 rounded text-center text-lg font-semibold focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <button onclick="applyMasterScale()" class="px-6 py-3 bg-black text-white font-semibold rounded-lg hover:bg-gray-800 transition-colors mt-6">Apply to All</button>
                    </div>
                    <!-- Quick Scale Buttons -->
                    <div class="grid grid-cols-4 gap-3">
                        <button onclick="setMasterScale(150)" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 text-sm font-medium">150% ‚Üí √ó1.5</button>
                        <button onclick="setMasterScale(200)" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 text-sm font-medium">200% ‚Üí √ó2</button>
                        <button onclick="setMasterScale(50)" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 text-sm font-medium">50% ‚Üí √ó0.5</button>
                        <button onclick="setMasterScale(75)" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300 text-sm font-medium">75% ‚Üí √ó0.75</button>
                    </div>
                </div>

                <!-- Slave/Node Scaling -->
                <div class="bg-white rounded-lg shadow-sm border border-blue-300 p-6 mb-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-2">üñ•Ô∏è Slave/Node Scaling</h3>
                    <div class="flex items-center gap-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-2">Number of Slaves</label>
                            <input type="number" id="slaveCount" value="1" min="1" max="100" step="1" 
                                onchange="updatePerformanceSummary()"
                                class="w-24 px-3 py-2 border border-gray-300 rounded text-center text-lg font-semibold focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <p class="text-sm text-gray-600 mt-6">Each thread group multiplied by this number</p>
                    </div>
                </div>

                <!-- Performance Summary -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 p-6">
                    <h3 class="text-lg font-bold text-gray-900 mb-4">üìä Performance Summary</h3>
                    <div class="grid grid-cols-2 md:grid-cols-5 gap-4">
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <div class="text-sm text-gray-600 mb-1">Active Groups</div>
                            <div class="text-2xl font-bold text-gray-900" id="activeGroups">0 / 0</div>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <div class="text-sm text-gray-600 mb-1">Original Users</div>
                            <div class="text-2xl font-bold text-blue-600" id="originalUsers">0</div>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <div class="text-sm text-gray-600 mb-1">Scaled Users</div>
                            <div class="text-2xl font-bold text-green-600" id="scaledUsers">0</div>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <div class="text-sm text-gray-600 mb-1">Original TPS</div>
                            <div class="text-2xl font-bold text-blue-600" id="originalTPS">104.22</div>
                        </div>
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <div class="text-sm text-gray-600 mb-1">Scaled TPS</div>
                            <div class="text-2xl font-bold text-green-600" id="scaledTPS">104.22</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-samplers" class="tab-content" style="display: none;">
                <!-- Search & Bulk Actions -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6 p-6">
                    <div class="flex gap-4 items-end">
                        <div class="flex-1">
                            <label class="block text-sm font-medium text-gray-700 mb-2">Search Samplers</label>
                            <input type="text" id="samplerSearch" placeholder="Search by name or URL..." 
                                oninput="filterSamplers()"
                                class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                        </div>
                        <button onclick="bulkDeleteSamplers()" 
                            class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition-colors font-medium">
                            Delete Selected
                        </button>
                    </div>
                </div>

                <!-- Samplers Table -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <div class="flex items-center justify-between">
                            <div>
                                <h3 class="text-lg font-bold text-gray-900">üì° HTTP Samplers</h3>
                                <p class="text-sm text-gray-600 mt-1">Clean up your recorded script by removing unwanted requests</p>
                            </div>
                            <button onclick="renameAllSamplersAction()" 
                                class="px-4 py-2 bg-green-600 text-white text-sm font-medium rounded hover:bg-green-700 transition-colors">
                                Rename All
                            </button>
                        </div>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-50 border-b border-gray-200">
                                <tr>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">
                                        <input type="checkbox" id="selectAllSamplers" onchange="toggleAllSamplers()" 
                                            class="rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                                    </th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">#</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Sampler Name</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Method</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">URL/Path</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="samplersTableBody" class="divide-y divide-gray-200">
                                <tr>
                                    <td colspan="6" class="px-4 py-8 text-center text-gray-500">No samplers found</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div id="content-variables" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-bold text-gray-900">üîß User Defined Variables</h3>
                            <button onclick="showAddVariableModal()" class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors text-sm font-medium">
                                + Add Variable
                            </button>
                        </div>
                        <!-- UDV Group Name -->
                        <div class="flex items-center gap-4">
                            <div class="flex-1">
                                <label class="block text-sm font-medium text-gray-700 mb-2">UDV Group Name</label>
                                <input type="text" id="udvGroupName" value="User Defined Variables" placeholder="User Defined Variables" 
                                    onfocus="if(this.value === 'User Defined Variables') this.value = ''" 
                                    onblur="if(this.value === '') this.value = 'User Defined Variables'"
                                    class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            </div>
                            <button onclick="updateUDVGroupName()" class="mt-6 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors text-sm font-medium">
                                Update Name
                            </button>
                        </div>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-50 border-b border-gray-200">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">#</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Variable Name</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Variable Value</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="variablesTableBody" class="divide-y divide-gray-200">
                                <tr>
                                    <td colspan="4" class="px-4 py-8 text-center text-gray-500">No variables found</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Find & Replace Section -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üîç Find & Replace</h3>
                        <p class="text-sm text-gray-600 mt-1">Search and replace text across all variable values</p>
                    </div>
                    <div class="p-6">
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Find Text</label>
                                <input type="text" id="findText" placeholder="e.g., dev-server" 
                                    class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            </div>
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Replace With</label>
                                <input type="text" id="replaceText" placeholder="e.g., prod-server" 
                                    class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                            </div>
                        </div>
                        <div class="flex gap-3">
                            <button onclick="findAndReplaceVariables()" 
                                class="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium">
                                Replace All
                            </button>
                            <button onclick="previewFindReplace()" 
                                class="px-6 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors font-medium">
                                Preview Changes
                            </button>
                        </div>
                        <div id="findReplaceResult" class="mt-4 p-4 bg-blue-50 border border-blue-200 rounded hidden">
                            <p class="text-sm text-blue-800"></p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-csv" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üìÅ CSV Data Manager</h3>
                        <p class="text-sm text-gray-600 mt-1">Configure CSV Data Sets with LoadRunner-style variants</p>
                    </div>
                    <div class="p-6">
                        <!-- Add CSV Config Section -->
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <h4 class="text-sm font-semibold text-gray-800 mb-3">Add CSV Data Set Config</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Config Type</label>
                                    <select id="csvType" onchange="updateCSVTypeFields()" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="CSVDataSet">Standard CSV Data Set</option>
                                        <option value="RandomCSVDataSet">Random CSV Data Set</option>
                                        <option value="ExtendedCSVDataSet">Extended CSV Data Set</option>
                                        <option value="UniqueCSVDataSet">Unique CSV Data Set</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Config Name</label>
                                    <input type="text" id="csvName" placeholder="e.g., User Credentials" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">File Path</label>
                                    <input type="text" id="csvFilePath" placeholder="e.g., data/users.csv" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">File Encoding</label>
                                    <input type="text" id="csvFileEncoding" value="UTF-8" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Variable Names (comma-separated)</label>
                                    <input type="text" id="csvVariables" placeholder="e.g., username,password" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Delimiter</label>
                                    <input type="text" id="csvDelimiter" value="," maxlength="1" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Sharing Mode</label>
                                    <select id="csvShareMode" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="shareMode.all">All threads</option>
                                        <option value="shareMode.group">Current thread group</option>
                                        <option value="shareMode.thread">Current thread</option>
                                    </select>
                                </div>
                                
                                <!-- Extended CSV specific fields -->
                                <div id="extendedSelectRow" class="hidden">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Select Row</label>
                                    <select id="csvSelectRow" onchange="updateExtendedFields()" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="Sequential">Sequential</option>
                                        <option value="Random">Random</option>
                                        <option value="Unique">Unique</option>
                                    </select>
                                </div>
                                <div id="extendedUpdateValues" class="hidden">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Update Values</label>
                                    <select id="csvUpdateValues" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="Each iteration">Each iteration</option>
                                        <option value="Once">Once</option>
                                    </select>
                                </div>
                                <div id="extendedOutOfValues" class="hidden">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">When out of Values</label>
                                    <select id="csvOutOfValues" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="Continue Cyclic">Continue Cyclic</option>
                                        <option value="Continue with last value">Continue with last value</option>
                                        <option value="Abort thread">Abort thread</option>
                                    </select>
                                </div>
                                <div id="extendedAllocateValues" class="hidden col-span-2">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Allocate values to thread</label>
                                    <div class="space-y-2">
                                        <div class="flex items-center">
                                            <input type="radio" id="csvAllocateAuto" name="csvAllocateMode" value="auto" checked
                                                class="w-4 h-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                            <label for="csvAllocateAuto" class="ml-2 text-sm text-gray-700">Automatically allocate block for threads</label>
                                        </div>
                                        <div class="flex items-center">
                                            <input type="radio" id="csvAllocateManual" name="csvAllocateMode" value="manual"
                                                class="w-4 h-4 text-blue-600 border-gray-300 focus:ring-blue-500">
                                            <label for="csvAllocateManual" class="ml-2 text-sm text-gray-700">Allocate</label>
                                            <input type="number" id="csvAllocateCount" value="1" min="1" 
                                                class="ml-2 w-20 px-2 py-1 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                            <span class="ml-2 text-sm text-gray-700">values for each thread</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Unique CSV specific fields -->
                                <div id="uniqueThreadGroup" class="hidden">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Target Thread Group</label>
                                    <input type="text" id="csvTargetThreadGroup" placeholder="Thread Group A" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div id="uniqueBlockSize" class="hidden">
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Block Size for Each Thread</label>
                                    <input type="number" id="csvBlockSize" value="1" min="1" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                            </div>
                            
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mt-4">
                                <!-- Standard/Unique CSV checkboxes -->
                                <div id="recycleCheck" class="flex items-center">
                                    <input type="checkbox" id="csvRecycle" checked 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvRecycle" class="ml-2 text-sm text-gray-700">Recycle on EOF</label>
                                </div>
                                <div id="stopThreadCheck" class="flex items-center">
                                    <input type="checkbox" id="csvStopThread" 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvStopThread" class="ml-2 text-sm text-gray-700">Stop thread on EOF</label>
                                </div>
                                <div id="ignoreFirstLineCheck" class="flex items-center">
                                    <input type="checkbox" id="csvIgnoreFirstLine" 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-2 focus:ring-blue-500">
                                    <label for="csvIgnoreFirstLine" class="ml-2 text-sm text-gray-700">Ignore first line</label>
                                </div>
                                <div id="allowQuotedCheck" class="flex items-center">
                                    <input type="checkbox" id="csvAllowQuoted" 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvAllowQuoted" class="ml-2 text-sm text-gray-700">Allow quoted data</label>
                                </div>
                                
                                <!-- Random CSV specific checkboxes -->
                                <div id="randomOrderCheck" class="flex items-center hidden">
                                    <input type="checkbox" id="csvRandomOrder" checked 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvRandomOrder" class="ml-2 text-sm text-gray-700">Random order</label>
                                </div>
                                <div id="rewindCheck" class="flex items-center hidden">
                                    <input type="checkbox" id="csvRewind" checked 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvRewind" class="ml-2 text-sm text-gray-700">Rewind on end of list</label>
                                </div>
                                <div id="headerCheck" class="flex items-center hidden">
                                    <input type="checkbox" id="csvFirstLineHeader" 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvFirstLineHeader" class="ml-2 text-sm text-gray-700">First line is CSV header</label>
                                </div>
                                <div id="independentCheck" class="flex items-center hidden">
                                    <input type="checkbox" id="csvIndependentList" 
                                        class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                                    <label for="csvIndependentList" class="ml-2 text-sm text-gray-700">Independent list per thread</label>
                                </div>
                            </div>
                            <button onclick="addCSVConfig()" 
                                class="mt-4 px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium">
                                Add CSV Config
                            </button>
                        </div>

                        <!-- CSV Configs Table -->
                        <div class="overflow-x-auto">
                            <div class="flex justify-between items-center mb-4">
                                <h4 class="text-sm font-semibold text-gray-800">Existing CSV Configs</h4>
                                <span id="csvCount" class="text-sm text-gray-600">0 configs</span>
                            </div>
                            <div id="csvTableContainer"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-timers" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">‚è±Ô∏è Timer Manager</h3>
                        <p class="text-sm text-gray-600 mt-1">Add think time delays for realistic user behavior simulation</p>
                    </div>
                    <div class="p-6">
                        <!-- Add Timer Section -->
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <h4 class="text-sm font-semibold text-gray-800 mb-3">Add New Timer</h4>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Target Thread Group</label>
                                    <select id="timerThreadGroup" onchange="updateTimerSamplerList()" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="">Select Thread Group</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Target Sampler</label>
                                    <select id="timerSampler" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="">Select Sampler (or leave empty for all)</option>
                                    </select>
                                </div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Timer Type</label>
                                    <select id="timerType" class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                        <option value="UniformRandomTimer">Uniform Random Timer</option>
                                        <option value="ConstantTimer">Constant Timer</option>
                                        <option value="GaussianRandomTimer">Gaussian Random Timer</option>
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Timer Name</label>
                                    <input type="text" id="timerName" placeholder="e.g., Think Time 3s" 
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Delay (ms)</label>
                                    <input type="number" id="timerDelay" value="3000" min="0" step="100"
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                            </div>
                            <div id="timerAdditionalOptions" class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Random Delay Maximum (ms)</label>
                                    <input type="number" id="timerRandomDelay" value="1000" min="0" step="100"
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                                <div>
                                    <label class="block text-sm font-medium text-gray-700 mb-2">Deviation (for Gaussian, ms)</label>
                                    <input type="number" id="timerDeviation" value="500" min="0" step="100"
                                        class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                </div>
                            </div>
                            <div class="flex gap-3 mt-4">
                                <button onclick="addTimer()" 
                                    class="px-6 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium">
                                    Add Timer
                                </button>
                                <button onclick="showBulkAddModal()" 
                                    class="px-6 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors font-medium">
                                    Bulk Add Think Time to All Samplers
                                </button>
                            </div>
                        </div>

                        <!-- Timers Table -->
                        <div class="overflow-x-auto">
                            <div class="flex justify-between items-center mb-4">
                                <h4 class="text-sm font-semibold text-gray-800">Existing Timers</h4>
                                <span id="timerCount" class="text-sm text-gray-600">0 timers</span>
                            </div>
                            <div id="timersTableContainer"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="content-workload" class="tab-content" style="display: none;">
                <!-- Mode Selector -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="p-6">
                        <div class="flex gap-4 mb-4">
                            <button onclick="switchWorkloadMode('scaling')" id="btn-scaling-mode" 
                                class="flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-blue-600 text-white">
                                üéØ TPS Scaling Calculator
                            </button>
                            <button onclick="switchWorkloadMode('littles')" id="btn-littles-mode"
                                class="flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-gray-200 text-gray-700 hover:bg-gray-300">
                                üìê Little's Law Calculator
                            </button>
                        </div>
                    </div>
                </div>

                <!-- TPS Scaling Calculator -->
                <div id="scaling-calculator" class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üéØ TPS Scaling Calculator</h3>
                        <p class="text-sm text-gray-600 mt-1">Quick proportional scaling based on target TPS</p>
                    </div>
                    <div class="p-6">
                        <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                            <p class="text-sm text-green-800 font-medium mb-2">üìä Proportional Scaling Formula</p>
                            <p class="text-xs text-green-700 mb-2">Scaling Factor = Target TPS / Current TPS</p>
                            <p class="text-xs text-green-700 mb-2">New Users = Current Users √ó Scaling Factor</p>
                            <p class="text-xs text-green-600"><strong>When to use:</strong> You have an existing test with known TPS and want to scale to a higher load while maintaining the same distribution across thread groups.</p>
                        </div>

                        <div id="scalingTableContainer" class="overflow-x-auto"></div>
                    </div>
                </div>

                <!-- Little's Law Calculator -->
                <div id="littles-calculator" class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6" style="display: none;">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üìê Little's Law Calculator</h3>
                        <p class="text-sm text-gray-600 mt-1">Engineering-precise calculation based on response times</p>
                    </div>
                    <div class="p-6">
                        <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <p class="text-sm text-blue-800 font-medium mb-2">üìê Extended Little's Law Formula</p>
                            <p class="text-xs text-blue-700 mb-2">U = TPS √ó (Total RT + Total TT + Pacing)</p>
                            <p class="text-xs text-blue-700 mb-2">TPS = U / (Total RT + Total TT + Pacing)</p>
                            <p class="text-xs text-blue-600"><strong>When to use:</strong> You're designing a test from scratch or need precise calculations based on actual response times, think times, and pacing for accurate system capacity analysis.</p>
                        </div>

                        <div id="workloadTableContainer" class="overflow-x-auto"></div>
                    </div>
                </div>
            </div>

            <div id="content-threadgroups" class="tab-content" style="display: none;">
                <div class="bg-white rounded-lg shadow-sm border border-gray-200">
                    <div class="px-6 py-4 border-b border-gray-200">
                        <h3 class="text-lg font-bold text-gray-900">üìã Thread Groups</h3>
                    </div>
                    <div class="overflow-x-auto">
                        <table class="w-full">
                            <thead class="bg-gray-50 border-b border-gray-200">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Status</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase">Name</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Users</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Ramp-Up <span class="normal-case">(secs)</span></th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Loop Count</th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Duration <span class="normal-case">(secs)</span></th>
                                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="threadGroupsTableBody" class="divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast Notification -->
    <div id="toast" class="fixed bottom-4 right-4 bg-black text-white px-6 py-3 rounded-lg shadow-lg transform transition-transform duration-300 translate-y-20 opacity-0" style="z-index: 1000;">
        <span id="toastMessage"></span>
    </div>

    <!-- Add Variable Modal -->
    <div id="addVariableModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[2000]" style="display: none;">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-gray-900 mb-4">Add New Variable</h3>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-2">Variable Name</label>
                <input type="text" id="newVarName" placeholder="e.g., hostname" 
                    class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">Variable Value</label>
                <input type="text" id="newVarValue" placeholder="e.g., example.com" 
                    class="w-full px-3 py-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="flex gap-3 justify-end">
                <button onclick="closeAddVariableModal()" 
                    class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-700 transition-colors">
                    Cancel
                </button>
                <button onclick="confirmAddVariable()" 
                    class="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors">
                    Add Variable
                </button>
            </div>
        </div>
    </div>

    <!-- Footer Watermark -->
    <footer class="fixed bottom-0 left-0 right-0 bg-white border-t border-gray-200 shadow-lg z-40">
        <div class="max-w-7xl mx-auto px-4 py-3">
            <div class="flex items-center justify-between text-xs text-gray-600">
                <div class="flex items-center gap-2">
                    <span class="font-medium text-gray-900">Developed by:</span>
                    <span class="font-semibold text-black">Sunil Sagar</span>
                    <span class="text-gray-400">|</span>
                    <span class="font-medium">Deloitte Consulting LLP</span>
                </div>
                <div class="text-gray-500">
                    ¬© 2025 All Rights Reserved
                </div>
            </div>
        </div>
    </footer>

    <!-- Load JavaScript Modules -->
    
    
    
    
    
    
    
    
    
    <script>
// Calculator Utilities - Performance testing formulas

/**
 * Extended Little's Law for Web Applications
 * U = TPS √ó (Total RT + Total TT + Pacing)
 * TPS = Transactions (iterations) per second
 */
function calculateVirtualUsers(tps, totalRT, totalTT, pacing = 0) {
    const iterationTime = totalRT + totalTT + pacing;
    
    const vus = tps * iterationTime;
    
    return {
        vus: vus,
        totalResponseTime: totalRT,
        totalThinkTime: totalTT,
        iterationTime: iterationTime,
        breakdown: `${tps} √ó (${totalRT.toFixed(2)} + ${totalTT.toFixed(2)} + ${pacing}) = ${vus.toFixed(2)}`
    };
}

/**
 * Calculate required pacing
 * Pacing = (Users / TPS) - Total RT - Total TT
 */
function calculatePacing(users, tps, totalRT, totalTT) {
    const pacing = (users / tps) - totalRT - totalTT;
    const calculatedPacing = Math.max(0, pacing);
    
    return {
        pacing: calculatedPacing,
        totalResponseTime: totalRT,
        totalThinkTime: totalTT,
        iterationTime: totalRT + totalTT + calculatedPacing,
        breakdown: `(${users} / ${tps}) - ${totalRT.toFixed(2)} - ${totalTT.toFixed(2)} = ${calculatedPacing.toFixed(2)}`
    };
}

/**
 * Calculate required TPS
 * TPS = Users / (Total RT + Total TT + Pacing)
 */
function calculateTPS(users, totalRT, totalTT, pacing) {
    const iterationTime = totalRT + totalTT + pacing;
    
    const tps = users / iterationTime;
    
    return {
        tps: tps,
        totalResponseTime: totalRT,
        totalThinkTime: totalTT,
        iterationTime: iterationTime,
        breakdown: `${users} / (${totalRT.toFixed(2)} + ${totalTT.toFixed(2)} + ${pacing}) = ${tps.toFixed(2)}`
    };
}

/**
 * Calculate required think time per page
 */
function calculateThinkTime(users, tps, numPages, responseTime, pacing) {
    const iterationsPerSecond = tps / numPages;
    const totalResponseTime = responseTime * numPages;
    
    const totalThinkTime = (users / iterationsPerSecond) - totalResponseTime - pacing;
    const thinkTimePerPage = totalThinkTime / (numPages - 1);
    
    return Math.max(0, thinkTimePerPage);
}

/**
 * Calculate concurrent users from business metrics
 * CU = (NSavg √ó SDavg) / 3600
 */
function calculateConcurrentUsers(sessionsPerHour, avgSessionDuration) {
    return Math.ceil((sessionsPerHour * avgSessionDuration) / 3600);
}

/**
 * Calculate throughput (TPS)
 * X = N / T
 */
function calculateThroughput(numRequests, totalTime) {
    return numRequests / totalTime;
}


// JMX Parser - Extract data from JMX XML

function parseJMX(xmlString) {
    const parser = new DOMParser();
    const jmxDocument = parser.parseFromString(xmlString, "text/xml");
    
    // Check for parse errors
    if (jmxDocument.querySelector('parsererror')) {
        return { error: 'Invalid XML format' };
    }
    
    // Extract all components
    const globalVariables = extractGlobalVariables(jmxDocument);
    const threadGroupData = extractThreadGroups(jmxDocument);
    const samplers = extractSamplers(jmxDocument);
    const csvConfigs = extractCSVConfigs(jmxDocument);
    const timers = extractTimers(jmxDocument);
    
    return {
        jmxDocument,
        globalVariables,
        threadGroupData,
        samplers,
        csvConfigs,
        timers,
        userDefinedVariables: extractUserDefinedVariables(jmxDocument).variables,
        userDefinedVariablesElement: extractUserDefinedVariables(jmxDocument).element
    };
}

function extractGlobalVariables(jmxDocument) {
    const argumentsList = jmxDocument.getElementsByTagName("Arguments");
    const variables = { rampup: "N/A", steadyState: "N/A", custom: {} };
    
    for (let i = 0; i < argumentsList.length; i++) {
        const arg = argumentsList[i];
        const testname = arg.getAttribute("testname");
        
        if (testname === "rampupSteadyDuration") {
            const elements = arg.getElementsByTagName("elementProp");
            for (let j = 0; j < elements.length; j++) {
                const nameNode = elements[j].getElementsByTagName("stringProp")[0];
                const valueNode = elements[j].getElementsByTagName("stringProp")[1];
                if (nameNode && valueNode) {
                    if (nameNode.textContent === "rampup") {
                        variables.rampup = valueNode.textContent;
                    }
                    if (nameNode.textContent === "steadyState") {
                        variables.steadyState = valueNode.textContent;
                    }
                }
            }
        } else if (testname === "User Defined Variables" || arg.getAttribute("guiclass") === "ArgumentsPanel") {
            // Extract all user-defined variables
            const elements = arg.getElementsByTagName("elementProp");
            for (let j = 0; j < elements.length; j++) {
                const nameNode = elements[j].getElementsByTagName("stringProp")[0];
                const valueNode = elements[j].getElementsByTagName("stringProp")[1];
                if (nameNode && valueNode) {
                    const varName = nameNode.textContent;
                    const varValue = valueNode.textContent;
                    variables.custom[varName] = varValue;
                }
            }
        }
    }
    
    return variables;
}

function extractThreadGroups(jmxDocument) {
    const threadGroups = jmxDocument.getElementsByTagName("ThreadGroup");
    const threadGroupData = [];
    
    for (let i = 0; i < threadGroups.length; i++) {
        const tg = threadGroups[i];
        const name = tg.getAttribute("testname");
        const enabled = tg.getAttribute("enabled") === "true" || tg.getAttribute("enabled") === null;
        
        // Extract user count
        let count = 1;
        const intProps = tg.getElementsByTagName("intProp");
        for (let j = 0; j < intProps.length; j++) {
            if (intProps[j].getAttribute("name") === "ThreadGroup.num_threads") {
                count = parseInt(intProps[j].textContent.trim(), 10);
                break;
            }
        }
        
        // Extract ramp-up time
        let rampTime = 1;
        const stringProps = tg.getElementsByTagName("stringProp");
        for (let j = 0; j < stringProps.length; j++) {
            if (stringProps[j].getAttribute("name") === "ThreadGroup.ramp_time") {
                rampTime = parseInt(stringProps[j].textContent.trim(), 10);
                break;
            }
        }
        
        // Extract duration
        let duration = 0;
        for (let j = 0; j < stringProps.length; j++) {
            if (stringProps[j].getAttribute("name") === "ThreadGroup.duration") {
                duration = parseInt(stringProps[j].textContent.trim(), 10);
                break;
            }
        }
        
        // Extract loops
        let loops = '1';
        const loopController = tg.querySelector('elementProp[name="ThreadGroup.main_controller"]');
        if (loopController) {
            const loopsProps = loopController.getElementsByTagName('stringProp');
            for (let j = 0; j < loopsProps.length; j++) {
                if (loopsProps[j].getAttribute('name') === 'LoopController.loops') {
                    loops = loopsProps[j].textContent.trim();
                    break;
                }
            }
        }
        
        // Extract throughput from PreciseThroughputTimer
        let throughput = 0;
        const tgHashTree = tg.nextElementSibling;
        if (tgHashTree && tgHashTree.tagName === "hashTree") {
            throughput = findThroughputInHashTree(tgHashTree);
        }
        
        threadGroupData.push({
            element: tg,
            name: name,
            count: count,
            originalCount: count,
            rampTime: rampTime,
            originalRampTime: rampTime,
            duration: duration,
            originalDuration: duration,
            loops: loops,
            status: enabled,
            throughput: throughput,
            originalThroughput: throughput
        });
    }
    
    return threadGroupData;
}

function findThroughputInHashTree(hashTree) {
    let throughput = 0;
    for (let child of hashTree.children) {
        if (child.tagName === "PreciseThroughputTimer") {
            const doubleProps = child.getElementsByTagName("doubleProp");
            for (let dp of doubleProps) {
                if (dp.getAttribute("name") === "throughput") {
                    const value = parseFloat(dp.textContent.trim());
                    if (!isNaN(value)) throughput += value;
                }
            }
        }
        if (child.tagName === "hashTree") {
            throughput += findThroughputInHashTree(child);
        }
    }
    return throughput;
}

function extractSamplers(jmxDocument) {
    const samplers = [];
    const httpSamplers = jmxDocument.getElementsByTagName("HTTPSamplerProxy");
    
    for (let i = 0; i < httpSamplers.length; i++) {
        const sampler = httpSamplers[i];
        const domain = getStringProp(sampler, "HTTPSampler.domain") || '';
        const path = getStringProp(sampler, "HTTPSampler.path") || '';
        const protocol = getStringProp(sampler, "HTTPSampler.protocol") || 'http';
        const method = getStringProp(sampler, "HTTPSampler.method") || 'GET';
        
        // Build full URL
        let url = path;
        if (domain) {
            url = `${protocol}://${domain}${path}`;
        }
        
        samplers.push({
            element: sampler,
            name: sampler.getAttribute("testname") || 'Unnamed Request',
            enabled: sampler.getAttribute("enabled") !== "false",
            domain: domain,
            path: path,
            method: method,
            protocol: protocol,
            url: url,
            originalIndex: i
        });
    }
    
    return samplers;
}

function extractCSVConfigs(jmxDocument) {
    const csvConfigs = [];
    const csvElements = jmxDocument.getElementsByTagName("CSVDataSet");
    
    for (let i = 0; i < csvElements.length; i++) {
        const csv = csvElements[i];
        csvConfigs.push({
            element: csv,
            name: csv.getAttribute("testname"),
            filename: getStringProp(csv, "filename"),
            variableNames: getStringProp(csv, "variableNames"),
            shareMode: getStringProp(csv, "shareMode")
        });
    }
    
    return csvConfigs;
}

function extractUserDefinedVariables(jmxDocument) {
    const argumentsList = jmxDocument.getElementsByTagName("Arguments");
    
    for (let i = 0; i < argumentsList.length; i++) {
        const arg = argumentsList[i];
        const testname = arg.getAttribute("testname");
        
        if (testname === "User Defined Variables" || arg.getAttribute("guiclass") === "ArgumentsPanel") {
            const variables = [];
            const collectionProp = arg.querySelector('collectionProp[name="Arguments.arguments"]');
            
            if (collectionProp) {
                const elements = collectionProp.getElementsByTagName("elementProp");
                for (let j = 0; j < elements.length; j++) {
                    const nameNode = elements[j].querySelector('stringProp[name="Argument.name"]');
                    const valueNode = elements[j].querySelector('stringProp[name="Argument.value"]');
                    
                    if (nameNode && valueNode) {
                        variables.push({
                            name: nameNode.textContent,
                            value: valueNode.textContent,
                            element: elements[j]
                        });
                    }
                }
            }
            
            return { variables, element: arg };
        }
    }
    
    return { variables: [], element: null };
}

function extractTimers(jmxDocument) {
    const timers = [];
    const timerTypes = [
        "ConstantTimer",
        "UniformRandomTimer",
        "GaussianRandomTimer",
        "PreciseThroughputTimer"
    ];
    
    timerTypes.forEach(type => {
        const elements = jmxDocument.getElementsByTagName(type);
        for (let i = 0; i < elements.length; i++) {
            const timer = elements[i];
            timers.push({
                element: timer,
                type: type,
                name: timer.getAttribute("testname"),
                enabled: timer.getAttribute("enabled") !== "false"
            });
        }
    });
    
    return timers;
}

function getStringProp(element, propName) {
    const props = element.getElementsByTagName("stringProp");
    for (let i = 0; i < props.length; i++) {
        if (props[i].getAttribute("name") === propName) {
            return props[i].textContent;
        }
    }
    return "";
}


// JMX Modifier - Modify and download JMX

function applyMasterScale(percent) {
    const factor = percent / 100;
    const state = window.appState;
    
    state.threadGroupData.forEach(tg => {
        const scaledThreads = Math.max(1, Math.ceil(tg.count * factor));
        tg.count = scaledThreads;
        updateThreadCountInXML(tg.element, scaledThreads);
        
        if (tg.throughput > 0) {
            tg.throughput = tg.originalThroughput * factor;
            const tgHashTree = tg.element.nextElementSibling;
            if (tgHashTree && tgHashTree.tagName === "hashTree") {
                updateThroughputInHashTree(tgHashTree, factor);
            }
        }
    });
}

function updateThreadCountInXML(tgElement, count) {
    let updated = false;
    const intProps = tgElement.getElementsByTagName("intProp");
    
    for (let i = 0; i < intProps.length; i++) {
        if (intProps[i].getAttribute("name") === "ThreadGroup.num_threads") {
            intProps[i].textContent = count.toString();
            updated = true;
            break;
        }
    }
    
    if (!updated) {
        const stringProps = tgElement.getElementsByTagName("stringProp");
        for (let i = 0; i < stringProps.length; i++) {
            if (stringProps[i].getAttribute("name") === "ThreadGroup.num_threads") {
                stringProps[i].textContent = count.toString();
                updated = true;
                break;
            }
        }
    }
    
    if (!updated) {
        const jmxDocument = window.appState.jmxDocument;
        const sp = jmxDocument.createElement("stringProp");
        sp.setAttribute("name", "ThreadGroup.num_threads");
        sp.textContent = count.toString();
        tgElement.appendChild(sp);
    }
}

function updateRampTimeInXML(tgElement, rampTime) {
    let updated = false;
    const stringProps = tgElement.getElementsByTagName("stringProp");
    
    for (let i = 0; i < stringProps.length; i++) {
        if (stringProps[i].getAttribute("name") === "ThreadGroup.ramp_time") {
            stringProps[i].textContent = rampTime.toString();
            updated = true;
            break;
        }
    }
    
    if (!updated) {
        const jmxDocument = window.appState.jmxDocument;
        const sp = jmxDocument.createElement("stringProp");
        sp.setAttribute("name", "ThreadGroup.ramp_time");
        sp.textContent = rampTime.toString();
        tgElement.appendChild(sp);
    }
}

function updateLoopCountInXML(tgElement, loopCount) {
    const loopController = tgElement.querySelector('elementProp[name="ThreadGroup.main_controller"]');
    if (loopController) {
        let updated = false;
        const intProps = loopController.getElementsByTagName('intProp');
        for (let i = 0; i < intProps.length; i++) {
            if (intProps[i].getAttribute('name') === 'LoopController.loops') {
                intProps[i].textContent = loopCount.toString();
                updated = true;
                break;
            }
        }
        
        if (!updated) {
            const jmxDocument = window.appState.jmxDocument;
            const ip = jmxDocument.createElement("intProp");
            ip.setAttribute("name", "LoopController.loops");
            ip.textContent = loopCount.toString();
            loopController.appendChild(ip);
        }
    }
}

function updateDurationInXML(tgElement, duration) {
    let updated = false;
    const stringProps = tgElement.getElementsByTagName("stringProp");
    
    for (let i = 0; i < stringProps.length; i++) {
        if (stringProps[i].getAttribute("name") === "ThreadGroup.duration") {
            stringProps[i].textContent = duration.toString();
            updated = true;
            break;
        }
    }
    
    if (!updated) {
        const jmxDocument = window.appState.jmxDocument;
        const sp = jmxDocument.createElement("stringProp");
        sp.setAttribute("name", "ThreadGroup.duration");
        sp.textContent = duration.toString();
        tgElement.appendChild(sp);
    }
}

function updateThroughputInHashTree(hashTree, multiplier) {
    for (let child of hashTree.children) {
        if (child.tagName === "PreciseThroughputTimer") {
            const doubleProps = child.getElementsByTagName("doubleProp");
            for (let dp of doubleProps) {
                if (dp.getAttribute("name") === "throughput") {
                    const current = parseFloat(dp.textContent.trim());
                    if (!isNaN(current)) {
                        dp.textContent = (current * multiplier).toString();
                    }
                }
            }
        }
        if (child.tagName === "hashTree") {
            updateThroughputInHashTree(child, multiplier);
        }
    }
}

function downloadJMX() {
    const jmxDocument = window.appState.jmxDocument;
    
    if (!jmxDocument) {
        return { success: false, error: 'No JMX loaded' };
    }
    
    try {
        // Update thread group configurations
        window.appState.threadGroupData.forEach(tg => {
            tg.element.setAttribute("enabled", tg.status.toString());
            updateThreadCountInXML(tg.element, tg.count);
        });
        
        // Serialize to XML
        const serializer = new XMLSerializer();
        let xmlString = serializer.serializeToString(jmxDocument);
        
        // Ensure XML declaration
        if (!xmlString.startsWith('<?xml')) {
            xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n' + xmlString;
        }
        
        // Create download
        const blob = new Blob([xmlString], { type: 'application/xml' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = 'modified_test_plan.jmx';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        return { success: true };
    } catch (error) {
        console.error('Download error:', error);
        return { success: false, error: error.message };
    }
}


// Sampler Manager - View, delete, rename, organize samplers
// Feature 1: Script cleaning after recording

function initSamplerManager() {
    console.log('Sampler Manager initialized');
}

function renderSamplersTable(filteredSamplers = null) {
    const tbody = document.getElementById('samplersTableBody');
    if (!tbody) return;
    
    const samplers = filteredSamplers || window.appState.samplers || [];
    
    if (samplers.length === 0) {
        tbody.innerHTML = '<tr><td colspan="6" class="px-4 py-8 text-center text-gray-500">No samplers found</td></tr>';
        return;
    }
    
    tbody.innerHTML = samplers.map((sampler, index) => `
        <tr class="${sampler.hidden ? 'hidden' : ''}">
            <td class="px-4 py-3 text-center">
                <input type="checkbox" 
                    id="checkbox-${sampler.originalIndex}"
                    class="sampler-checkbox rounded border-gray-300 text-blue-600 focus:ring-blue-500" 
                    data-index="${sampler.originalIndex}">
            </td>
            <td class="px-4 py-3 text-sm text-gray-600">${sampler.originalIndex + 1}</td>
            <td class="px-4 py-3">
                <input type="text" 
                    id="sampler-name-${sampler.originalIndex}" 
                    value="${escapeHtml(sampler.name)}" 
                    oninput="document.getElementById('checkbox-${sampler.originalIndex}').checked = true"
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </td>
            <td class="px-4 py-3">
                <span class="inline-flex items-center px-2 py-1 rounded text-xs font-medium ${getMethodClass(sampler.method)}">
                    ${sampler.method}
                </span>
            </td>
            <td class="px-4 py-3 text-sm text-gray-700 truncate max-w-md" title="${escapeHtml(sampler.url)}">
                ${escapeHtml(sampler.url)}
            </td>
            <td class="px-4 py-3 text-center">
                <button onclick="renameSampler(${sampler.originalIndex})" 
                    class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700 transition-colors mr-2">
                    Rename
                </button>
                <button onclick="deleteSampler(${sampler.originalIndex})" 
                    class="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700 transition-colors">
                    Delete
                </button>
            </td>
        </tr>
    `).join('');
}

function deleteSampler(index) {
    const samplers = window.appState.samplers || [];
    const sampler = samplers.find(s => s.originalIndex === index);
    
    if (!sampler) {
        return { success: false, error: 'Sampler not found' };
    }
    
    // Remove from XML
    if (sampler.element && sampler.element.parentNode) {
        const hashTree = sampler.element.nextElementSibling;
        if (hashTree && hashTree.tagName === 'hashTree') {
            hashTree.parentNode.removeChild(hashTree);
        }
        sampler.element.parentNode.removeChild(sampler.element);
    }
    
    // Remove from state
    const samplerIndex = samplers.indexOf(sampler);
    if (samplerIndex > -1) {
        samplers.splice(samplerIndex, 1);
    }
    
    return { success: true };
}

function renameSampler(index) {
    const samplers = window.appState.samplers || [];
    const sampler = samplers.find(s => s.originalIndex === index);
    
    if (!sampler) {
        return { success: false, error: 'Sampler not found' };
    }
    
    const newName = document.getElementById(`sampler-name-${index}`).value.trim();
    
    if (!newName) {
        return { success: false, error: 'Sampler name cannot be empty' };
    }
    
    // Update XML
    sampler.element.setAttribute('testname', newName);
    sampler.name = newName;
    
    return { success: true };
}

function renameAllSamplers() {
    const samplers = window.appState.samplers || [];
    let renamedCount = 0;
    let emptyCount = 0;
    
    samplers.forEach(sampler => {
        const inputField = document.getElementById(`sampler-name-${sampler.originalIndex}`);
        if (inputField) {
            const newName = inputField.value.trim();
            
            if (!newName) {
                emptyCount++;
            } else {
                // Always update if name is valid
                const currentXmlName = sampler.element.getAttribute('testname');
                if (currentXmlName !== newName) {
                    sampler.element.setAttribute('testname', newName);
                    sampler.name = newName;
                    renamedCount++;
                }
            }
        }
    });
    
    if (emptyCount > 0) {
        return { success: false, error: `${emptyCount} sampler(s) have empty names`, count: renamedCount };
    }
    
    return { success: true, count: renamedCount };
}

function bulkDeleteSamplers() {
    const checkboxes = document.querySelectorAll('.sampler-checkbox:checked');
    const indices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index));
    
    if (indices.length === 0) {
        return { success: false, error: 'No samplers selected', count: 0 };
    }
    
    let deletedCount = 0;
    
    // Delete in reverse order to maintain indices
    indices.sort((a, b) => b - a).forEach(index => {
        const result = deleteSampler(index);
        if (result.success) {
            deletedCount++;
        }
    });
    
    return { success: true, count: deletedCount };
}

function filterSamplers(searchTerm) {
    const samplers = window.appState.samplers || [];
    
    if (!searchTerm || searchTerm.trim() === '') {
        return samplers;
    }
    
    const term = searchTerm.toLowerCase();
    return samplers.filter(s => 
        s.name.toLowerCase().includes(term) || 
        s.url.toLowerCase().includes(term)
    );
}

function getMethodClass(method) {
    const classes = {
        'GET': 'bg-green-100 text-green-800',
        'POST': 'bg-blue-100 text-blue-800',
        'PUT': 'bg-yellow-100 text-yellow-800',
        'DELETE': 'bg-red-100 text-red-800',
        'PATCH': 'bg-purple-100 text-purple-800'
    };
    return classes[method] || 'bg-gray-100 text-gray-800';
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}



// Variables Manager - Manage user-defined variables
// Feature 2: Add, edit, delete variables with find & replace

function initVariablesManager() {
    console.log('Variables Manager initialized');
}

function renderVariablesTable() {
    const tbody = document.getElementById('variablesTableBody');
    if (!tbody) return;
    
    const variables = window.appState.userDefinedVariables || [];
    
    // Load current UDV group name
    const udvGroupNameInput = document.getElementById('udvGroupName');
    if (udvGroupNameInput && window.appState.userDefinedVariablesElement) {
        const currentName = window.appState.userDefinedVariablesElement.getAttribute('testname');
        udvGroupNameInput.value = currentName || 'User Defined Variables';
    }
    
    if (variables.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" class="px-4 py-8 text-center text-gray-500">No variables found</td></tr>';
        return;
    }
    
    tbody.innerHTML = variables.map((variable, index) => `
        <tr>
            <td class="px-4 py-3 text-sm text-gray-600">${index + 1}</td>
            <td class="px-4 py-3 text-sm font-medium text-gray-900">${escapeHtml(variable.name)}</td>
            <td class="px-4 py-3">
                <input type="text" 
                    id="var-value-${index}" 
                    value="${escapeHtml(variable.value)}" 
                    class="w-full px-3 py-2 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
            </td>
            <td class="px-4 py-3 text-center">
                <button onclick="updateVariable(${index})" 
                    class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700 transition-colors mr-2">
                    Update
                </button>
                <button onclick="deleteVariable(${index})" 
                    class="px-3 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700 transition-colors">
                    Delete
                </button>
            </td>
        </tr>
    `).join('');
}

function addVariable(name, value) {
    if (!name || !name.trim()) {
        return { success: false, error: 'Variable name is required' };
    }
    
    const variables = window.appState.userDefinedVariables || [];
    
    // Check for duplicate
    const exists = variables.find(v => v.name === name);
    if (exists) {
        return { success: false, error: 'Variable already exists' };
    }
    
    // Get Arguments element from JMX
    const argumentsElement = window.appState.userDefinedVariablesElement;
    if (!argumentsElement) {
        return { success: false, error: 'User Defined Variables element not found' };
    }
    
    // Get collectionProp
    let collectionProp = argumentsElement.querySelector('collectionProp[name="Arguments.arguments"]');
    if (!collectionProp) {
        const jmxDoc = window.appState.jmxDocument;
        collectionProp = jmxDoc.createElement('collectionProp');
        collectionProp.setAttribute('name', 'Arguments.arguments');
        argumentsElement.appendChild(collectionProp);
    }
    
    // Create new elementProp
    const jmxDoc = window.appState.jmxDocument;
    const elementProp = jmxDoc.createElement('elementProp');
    elementProp.setAttribute('name', name);
    elementProp.setAttribute('elementType', 'Argument');
    
    const nameNode = jmxDoc.createElement('stringProp');
    nameNode.setAttribute('name', 'Argument.name');
    nameNode.textContent = name;
    
    const valueNode = jmxDoc.createElement('stringProp');
    valueNode.setAttribute('name', 'Argument.value');
    valueNode.textContent = value;
    
    const metadataNode = jmxDoc.createElement('stringProp');
    metadataNode.setAttribute('name', 'Argument.metadata');
    metadataNode.textContent = '=';
    
    elementProp.appendChild(nameNode);
    elementProp.appendChild(valueNode);
    elementProp.appendChild(metadataNode);
    
    collectionProp.appendChild(elementProp);
    
    // Update state
    variables.push({ name, value, element: elementProp });
    window.appState.userDefinedVariables = variables;
    
    return { success: true };
}

function updateVariable(index) {
    const variables = window.appState.userDefinedVariables || [];
    if (index < 0 || index >= variables.length) {
        return { success: false, error: 'Invalid variable index' };
    }
    
    const newValue = document.getElementById(`var-value-${index}`).value;
    const variable = variables[index];
    
    // Update XML
    const valueNode = variable.element.querySelector('stringProp[name="Argument.value"]');
    if (valueNode) {
        valueNode.textContent = newValue;
        variable.value = newValue;
        return { success: true };
    }
    
    return { success: false, error: 'Failed to update variable' };
}

function deleteVariable(index) {
    const variables = window.appState.userDefinedVariables || [];
    if (index < 0 || index >= variables.length) {
        return { success: false, error: 'Invalid variable index' };
    }
    
    const variable = variables[index];
    
    // Remove from XML
    if (variable.element && variable.element.parentNode) {
        variable.element.parentNode.removeChild(variable.element);
    }
    
    // Remove from state
    variables.splice(index, 1);
    window.appState.userDefinedVariables = variables;
    
    return { success: true };
}

function findAndReplace(findText, replaceText) {
    if (!findText) {
        return { success: false, error: 'Find text is required', count: 0 };
    }
    
    const variables = window.appState.userDefinedVariables || [];
    let replacementCount = 0;
    
    variables.forEach(variable => {
        if (variable.value.includes(findText)) {
            const newValue = variable.value.replaceAll(findText, replaceText);
            const valueNode = variable.element.querySelector('stringProp[name="Argument.value"]');
            if (valueNode) {
                valueNode.textContent = newValue;
                variable.value = newValue;
                replacementCount++;
            }
        }
    });
    
    return { success: true, count: replacementCount };
}

function previewFindReplace(findText) {
    if (!findText) {
        return { matches: [] };
    }
    
    const variables = window.appState.userDefinedVariables || [];
    const matches = variables.filter(v => v.value.includes(findText));
    
    return { matches };
}

function updateUDVGroupName() {
    const udvElement = window.appState.userDefinedVariablesElement;
    if (!udvElement) {
        return { success: false, error: 'No UDV element found' };
    }
    
    let newName = document.getElementById('udvGroupName').value.trim();
    // Use default if empty
    if (!newName) {
        newName = 'User Defined Variables';
    }
    
    // Update the testname attribute
    udvElement.setAttribute('testname', newName);
    
    return { success: true, message: `UDV group renamed to "${newName}"` };
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}



// CSV Manager - Configure CSV Data Set (all variants)
// Feature 3: LoadRunner-style parameterization

function initCSVManager() {
    console.log('CSV Manager initialized');
}

function renderCSVTable() {
    const csvConfigs = window.appState.csvConfigs || [];
    const container = document.getElementById('csvTableContainer');
    
    document.getElementById('csvCount').textContent = `${csvConfigs.length} config${csvConfigs.length !== 1 ? 's' : ''}`;
    
    if (csvConfigs.length === 0) {
        container.innerHTML = `
            <div class="text-center py-12 text-gray-500">
                <p class="mb-2">No CSV Data Set configs found</p>
                <p class="text-sm">Add CSV configs above to parameterize your test</p>
            </div>
        `;
        return;
    }
    
    let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Config Name</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Type</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">File Path</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Variables</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Share Mode</th>
                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase tracking-wider">Actions</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
    `;
    
    csvConfigs.forEach((config, index) => {
        const typeBadge = getCSVTypeBadge(config.type);
        const shareMode = getShareModeLabel(config.shareMode);
        
        html += `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-4 py-3 text-sm font-medium text-gray-900">${config.name || 'Unnamed Config'}</td>
                <td class="px-4 py-3 text-sm">${typeBadge}</td>
                <td class="px-4 py-3 text-sm text-gray-600 font-mono">${config.filename || 'N/A'}</td>
                <td class="px-4 py-3 text-sm text-gray-600 font-mono">${config.variableNames || 'N/A'}</td>
                <td class="px-4 py-3 text-sm text-gray-600">${shareMode}</td>
                <td class="px-4 py-3 text-sm text-center">
                    <button onclick="editCSVConfig(${index})" 
                        class="text-blue-600 hover:text-blue-800 mr-3 font-medium">
                        Edit
                    </button>
                    <button onclick="deleteCSVConfig(${index})" 
                        class="text-red-600 hover:text-red-800 font-medium">
                        Delete
                    </button>
                </td>
            </tr>
        `;
    });
    
    html += '</tbody></table>';
    container.innerHTML = html;
}

function getCSVTypeBadge(type) {
    const badges = {
        'CSVDataSet': '<span class="px-2 py-1 text-xs font-semibold text-blue-800 bg-blue-100 rounded">Standard CSV</span>',
        'RandomCSVDataSet': '<span class="px-2 py-1 text-xs font-semibold text-green-800 bg-green-100 rounded">Random CSV</span>',
        'ExtendedCSVDataSet': '<span class="px-2 py-1 text-xs font-semibold text-purple-800 bg-purple-100 rounded">Extended CSV</span>',
        'UniqueCSVDataSet': '<span class="px-2 py-1 text-xs font-semibold text-orange-800 bg-orange-100 rounded">Unique CSV</span>'
    };
    return badges[type] || '<span class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 rounded">Unknown</span>';
}

function getShareModeLabel(shareMode) {
    const modes = {
        'shareMode.all': 'All threads',
        'shareMode.group': 'Thread group',
        'shareMode.thread': 'Current thread'
    };
    return modes[shareMode] || shareMode;
}

function addCSVConfig(type, config) {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) {
        return { success: false, error: 'No JMX file loaded' };
    }
    
    // Find Test Plan's hashTree (top level)
    const testPlan = jmxDoc.getElementsByTagName('TestPlan')[0];
    if (!testPlan) {
        return { success: false, error: 'No Test Plan found' };
    }
    
    const testPlanHashTree = testPlan.nextElementSibling;
    if (!testPlanHashTree || testPlanHashTree.tagName !== 'hashTree') {
        return { success: false, error: 'Invalid JMX structure' };
    }
    
    // Create appropriate CSV element based on type
    let csvElement, guiClass, testClass;
    
    if (type === 'RandomCSVDataSet') {
        csvElement = jmxDoc.createElement('com.blazemeter.jmeter.RandomCSVDataSetConfig');
        guiClass = 'com.blazemeter.jmeter.RandomCSVDataSetConfigGui';
        testClass = 'com.blazemeter.jmeter.RandomCSVDataSetConfig';
    } else if (type === 'ExtendedCSVDataSet') {
        csvElement = jmxDoc.createElement('com.di.jmeter.config.ExtendedCsvDataSetConfig');
        guiClass = 'com.di.jmeter.config.gui.ExtendedCsvDataSetConfigGui';
        testClass = 'com.di.jmeter.config.ExtendedCsvDataSetConfig';
    } else if (type === 'UniqueCSVDataSet') {
        csvElement = jmxDoc.createElement('dukhi.a.jmeter.config.UniqueCSVDataSet');
        guiClass = 'TestBeanGUI';
        testClass = 'dukhi.a.jmeter.config.UniqueCSVDataSet';
    } else {
        // Standard CSVDataSet
        csvElement = jmxDoc.createElement('CSVDataSet');
        guiClass = 'TestBeanGUI';
        testClass = 'CSVDataSet';
    }
    
    csvElement.setAttribute('guiclass', guiClass);
    csvElement.setAttribute('testclass', testClass);
    csvElement.setAttribute('testname', config.name);
    
    csvElement.setAttribute('guiclass', guiClass);
    csvElement.setAttribute('testclass', testClass);
    csvElement.setAttribute('testname', config.name);
    
    // Add properties based on type
    if (type === 'CSVDataSet') {
        // Standard CSV - exact structure from JMeter
        addStringProp(csvElement, 'delimiter', config.delimiter);
        addStringProp(csvElement, 'fileEncoding', config.fileEncoding || '');
        addStringProp(csvElement, 'filename', config.filename);
        addBoolProp(csvElement, 'ignoreFirstLine', config.ignoreFirstLine || false);
        addBoolProp(csvElement, 'quotedData', config.allowQuoted || false);
        addBoolProp(csvElement, 'recycle', config.recycle !== undefined ? config.recycle : true);
        addStringProp(csvElement, 'shareMode', config.shareMode || 'shareMode.all');
        addBoolProp(csvElement, 'stopThread', config.stopThread || false);
        addStringProp(csvElement, 'variableNames', config.variableNames);
    } else if (type === 'RandomCSVDataSet') {
        // BlazeMeter Random CSV
        addStringProp(csvElement, 'filename', config.filename);
        addStringProp(csvElement, 'fileEncoding', config.fileEncoding || 'UTF-8');
        addStringProp(csvElement, 'delimiter', config.delimiter);
        addStringProp(csvElement, 'variableNames', config.variableNames);
        addBoolProp(csvElement, 'randomOrder', config.randomOrder || true);
        addBoolProp(csvElement, 'ignoreFirstLine', config.ignoreFirstLine || false);
        addBoolProp(csvElement, 'rewindOnTheEndOfList', config.rewind !== undefined ? config.rewind : true);
        addBoolProp(csvElement, 'independentListPerThread', config.independentList || false);
    } else if (type === 'ExtendedCSVDataSet') {
        // Di Extended CSV
        addStringProp(csvElement, 'filename', config.filename);
        addStringProp(csvElement, 'fileEncoding', config.fileEncoding || 'UTF-8');
        addStringProp(csvElement, 'variableNames', config.variableNames);
        addBoolProp(csvElement, 'ignoreFirstLine', config.ignoreFirstLine || true);
        addStringProp(csvElement, 'delimiter', config.delimiter);
        addBoolProp(csvElement, 'quotedData', config.allowQuoted || false);
        addStringProp(csvElement, 'selectRow', config.selectRow || 'Sequential');
        addStringProp(csvElement, 'updateValue', config.updateValues || 'Each Iteration');
        addStringProp(csvElement, 'ooValue', config.outOfValues || 'Continue Cyclic');
        addStringProp(csvElement, 'shareMode', config.shareMode || 'All threads');
        addBoolProp(csvElement, 'autoAllocate', config.allocateMode === 'Auto');
        addBoolProp(csvElement, 'allocate', config.allocateMode === 'Manual');
        addStringProp(csvElement, 'blockSize', config.allocateCount ? config.allocateCount.toString() : '');
    } else if (type === 'UniqueCSVDataSet') {
        // Dukhi Unique CSV
        addIntProp(csvElement, 'blockSize', config.blockSize || 1);
        addStringProp(csvElement, 'delimiter', config.delimiter);
        addStringProp(csvElement, 'fileEncoding', config.fileEncoding || '');
        addStringProp(csvElement, 'filename', config.filename);
        addBoolProp(csvElement, 'ignoreFirstLine', config.ignoreFirstLine || false);
        addBoolProp(csvElement, 'quotedData', config.allowQuoted || false);
        addBoolProp(csvElement, 'recycle', config.recycle !== undefined ? config.recycle : true);
        addStringProp(csvElement, 'shareMode', config.shareMode || 'shareMode.all');
        addBoolProp(csvElement, 'stopThread', config.stopThread || false);
        addStringProp(csvElement, 'threadGroup', config.targetThreadGroup || 'Thread Group A');
        addStringProp(csvElement, 'variableNames', config.variableNames);
    }
    
    // Helper functions
    function addStringProp(parent, name, value) {
        const prop = jmxDoc.createElement('stringProp');
        prop.setAttribute('name', name);
        prop.textContent = value || '';
        parent.appendChild(prop);
    }
    
    function addBoolProp(parent, name, value) {
        const prop = jmxDoc.createElement('boolProp');
        prop.setAttribute('name', name);
        prop.textContent = value ? 'true' : 'false';
        parent.appendChild(prop);
    }
    
    function addIntProp(parent, name, value) {
        const prop = jmxDoc.createElement('intProp');
        prop.setAttribute('name', name);
        prop.textContent = value.toString();
        parent.appendChild(prop);
    }
    
    // Add to Test Plan level (after UDV/Arguments, before first ThreadGroup)
    const threadGroups = jmxDoc.getElementsByTagName('ThreadGroup');
    if (threadGroups.length > 0) {
        // Insert before first thread group
        testPlanHashTree.insertBefore(csvElement, threadGroups[0]);
        const emptyHashTree = jmxDoc.createElement('hashTree');
        testPlanHashTree.insertBefore(emptyHashTree, threadGroups[0]);
    } else {
        // No thread groups, append at end
        testPlanHashTree.appendChild(csvElement);
        const emptyHashTree = jmxDoc.createElement('hashTree');
        testPlanHashTree.appendChild(emptyHashTree);
    }
    
    // Update state
    if (!window.appState.csvConfigs) {
        window.appState.csvConfigs = [];
    }
    
    window.appState.csvConfigs.push({
        element: csvElement,
        type: type,
        ...config
    });
    
    return { success: true };
}

// No longer needed - always use CSVDataSet
// function getGuiClass(type) {
//     return 'TestBeanGUI';
// }

function deleteCSVConfig(index) {
    const csvConfigs = window.appState.csvConfigs;
    if (!csvConfigs || index < 0 || index >= csvConfigs.length) {
        return { success: false, error: 'Invalid config index' };
    }
    
    const config = csvConfigs[index];
    const element = config.element;
    
    // Remove element and its hashTree
    const hashTree = element.nextElementSibling;
    if (hashTree && hashTree.tagName === 'hashTree') {
        hashTree.remove();
    }
    element.remove();
    
    // Remove from state
    csvConfigs.splice(index, 1);
    
    return { success: true };
}

function editCSVConfig(index) {
    const csvConfigs = window.appState.csvConfigs;
    if (!csvConfigs || index < 0 || index >= csvConfigs.length) {
        return { success: false, error: 'Invalid config index' };
    }
    
    const config = csvConfigs[index];
    
    // Populate common form fields
    document.getElementById('csvType').value = config.type;
    document.getElementById('csvName').value = config.name;
    document.getElementById('csvFilePath').value = config.filename;
    document.getElementById('csvFileEncoding').value = config.fileEncoding || 'UTF-8';
    document.getElementById('csvVariables').value = config.variableNames;
    document.getElementById('csvDelimiter').value = config.delimiter;
    
    // Trigger type field visibility
    window.updateCSVTypeFields();
    
    // Populate type-specific fields
    if (config.type === 'CSVDataSet') {
        document.getElementById('csvShareMode').value = config.shareMode;
        document.getElementById('csvRecycle').checked = config.recycle;
        document.getElementById('csvStopThread').checked = config.stopThread;
        document.getElementById('csvIgnoreFirstLine').checked = config.ignoreFirstLine;
        document.getElementById('csvAllowQuoted').checked = config.allowQuoted;
    } else if (config.type === 'RandomCSVDataSet') {
        document.getElementById('csvRandomOrder').checked = config.randomOrder;
        document.getElementById('csvRewind').checked = config.rewind;
        document.getElementById('csvFirstLineHeader').checked = config.firstLineHeader;
        document.getElementById('csvIndependentList').checked = config.independentList;
    } else if (config.type === 'ExtendedCSVDataSet') {
        document.getElementById('csvShareMode').value = config.shareMode;
        document.getElementById('csvIgnoreFirstLine').checked = config.ignoreFirstLine;
        document.getElementById('csvAllowQuoted').checked = config.allowQuoted;
        document.getElementById('csvSelectRow').value = config.selectRow;
        document.getElementById('csvUpdateValues').value = config.updateValues;
        document.getElementById('csvOutOfValues').value = config.outOfValues;
        if (config.allocateMode === 'auto') {
            document.getElementById('csvAllocateAuto').checked = true;
        } else {
            document.getElementById('csvAllocateManual').checked = true;
            document.getElementById('csvAllocateCount').value = config.allocateCount || 1;
        }
        window.updateExtendedFields();
    } else if (config.type === 'UniqueCSVDataSet') {
        document.getElementById('csvShareMode').value = config.shareMode;
        document.getElementById('csvRecycle').checked = config.recycle;
        document.getElementById('csvStopThread').checked = config.stopThread;
        document.getElementById('csvIgnoreFirstLine').checked = config.ignoreFirstLine;
        document.getElementById('csvAllowQuoted').checked = config.allowQuoted;
        document.getElementById('csvTargetThreadGroup').value = config.targetThreadGroup || '';
        document.getElementById('csvBlockSize').value = config.blockSize || 1;
    }
    
    // Delete old config
    deleteCSVConfig(index);
    
    // Scroll to form
    document.getElementById('csvType').scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    return { success: true };
}


// Timer Manager - Add think time and pacing
// Feature 4: Realistic user behavior simulation

function initTimerManager() {
    console.log('Timer Manager initialized');
}

function populateTimerDropdowns() {
    const threadGroupSelect = document.getElementById('timerThreadGroup');
    if (!threadGroupSelect) return;
    
    const threadGroups = window.appState.threadGroupData || [];
    threadGroupSelect.innerHTML = '<option value="">Select Thread Group</option>';
    
    threadGroups.forEach((tg, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = tg.name;
        threadGroupSelect.appendChild(option);
    });
}

function updateTimerSamplerList() {
    const threadGroupIndex = parseInt(document.getElementById('timerThreadGroup').value);
    const samplerSelect = document.getElementById('timerSampler');
    
    if (!samplerSelect) return;
    
    samplerSelect.innerHTML = '<option value="">Select Sampler (or leave empty for all)</option>';
    
    if (isNaN(threadGroupIndex)) {
        // Reset to default when no thread group selected
        return;
    }
    
    // Change text when thread group is selected
    samplerSelect.innerHTML = '<option value="">All samplers in this thread group</option>';
    
    const samplers = window.appState.samplers || [];
    const threadGroup = window.appState.threadGroupData[threadGroupIndex];
    
    if (!threadGroup) return;
    
    // Find samplers that belong to this thread group
    const tgElement = threadGroup.element;
    const tgHashTree = tgElement.nextElementSibling;
    
    if (!tgHashTree || tgHashTree.tagName !== 'hashTree') return;
    
    samplers.forEach((sampler, index) => {
        // Check if this sampler is a descendant of the thread group's hashTree
        if (tgHashTree.contains(sampler.element)) {
            const option = document.createElement('option');
            option.value = sampler.originalIndex;
            option.textContent = sampler.name;
            samplerSelect.appendChild(option);
        }
    });
}

function renderTimersTable() {
    const timers = window.appState.timers || [];
    const container = document.getElementById('timersTableContainer');
    
    document.getElementById('timerCount').textContent = `${timers.length} timer${timers.length !== 1 ? 's' : ''}`;
    
    if (timers.length === 0) {
        container.innerHTML = `
            <div class="text-center py-12 text-gray-500">
                <p class="mb-2">No timers found in this JMX file</p>
                <p class="text-sm">Add timers above to control think time and pacing</p>
            </div>
        `;
        return;
    }
    
    let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Timer Name</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Type</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Configuration</th>
                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-700 uppercase tracking-wider">Status</th>
                    <th class="px-4 py-3 text-center text-xs font-medium text-gray-700 uppercase tracking-wider">Actions</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
    `;
    
    timers.forEach((timer, index) => {
        const statusBadge = timer.enabled 
            ? '<span class="px-2 py-1 text-xs font-semibold text-green-800 bg-green-100 rounded">Enabled</span>'
            : '<span class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 rounded">Disabled</span>';
        
        const typeBadge = getTimerTypeBadge(timer.type);
        const config = getTimerConfig(timer);
        
        html += `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-4 py-3 text-sm font-medium text-gray-900">${timer.name || 'Unnamed Timer'}</td>
                <td class="px-4 py-3 text-sm">${typeBadge}</td>
                <td class="px-4 py-3 text-sm text-gray-600 font-mono">${config}</td>
                <td class="px-4 py-3 text-sm">${statusBadge}</td>
                <td class="px-4 py-3 text-sm text-center">
                    <button onclick="toggleTimer(${index})" 
                        class="text-blue-600 hover:text-blue-800 mr-3 font-medium">
                        ${timer.enabled ? 'Disable' : 'Enable'}
                    </button>
                    <button onclick="deleteTimer(${index})" 
                        class="text-red-600 hover:text-red-800 font-medium">
                        Delete
                    </button>
                </td>
            </tr>
        `;
    });
    
    html += '</tbody></table>';
    container.innerHTML = html;
}

function getTimerTypeBadge(type) {
    const badges = {
        'UniformRandomTimer': '<span class="px-2 py-1 text-xs font-semibold text-blue-800 bg-blue-100 rounded">Uniform Random</span>',
        'ConstantTimer': '<span class="px-2 py-1 text-xs font-semibold text-purple-800 bg-purple-100 rounded">Constant</span>',
        'GaussianRandomTimer': '<span class="px-2 py-1 text-xs font-semibold text-indigo-800 bg-indigo-100 rounded">Gaussian Random</span>'
    };
    return badges[type] || '<span class="px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 rounded">Unknown</span>';
}

function getTimerConfig(timer) {
    const element = timer.element;
    const type = timer.type;
    
    if (type === 'ConstantTimer') {
        const delay = getStringProp(element, 'ConstantTimer.delay') || '0';
        return `Delay: ${delay}ms`;
    } else if (type === 'UniformRandomTimer') {
        const delay = getStringProp(element, 'ConstantTimer.delay') || '0';
        const range = getStringProp(element, 'RandomTimer.range') || '0';
        return `Delay: ${delay}ms, Range: ${range}ms`;
    } else if (type === 'GaussianRandomTimer') {
        const delay = getStringProp(element, 'ConstantTimer.delay') || '0';
        const range = getStringProp(element, 'RandomTimer.range') || '0';
        return `Offset: ${delay}ms, Deviation: ${range}ms`;
    }
    
    return 'N/A';
}

function getStringProp(element, propName) {
    const props = element.getElementsByTagName('stringProp');
    for (let i = 0; i < props.length; i++) {
        if (props[i].getAttribute('name') === propName) {
            return props[i].textContent;
        }
    }
    return '';
}

function getDoubleProp(element, propName) {
    const props = element.getElementsByTagName('doubleProp');
    for (let i = 0; i < props.length; i++) {
        if (props[i].getAttribute('name') === propName) {
            return props[i].textContent;
        }
    }
    return '';
}

function getIntProp(element, propName) {
    const props = element.getElementsByTagName('intProp');
    for (let i = 0; i < props.length; i++) {
        if (props[i].getAttribute('name') === propName) {
            return props[i].textContent;
        }
    }
    return '';
}

function addTimer(type, name, delay, randomDelay = 0, deviation = 0, threadGroupIndex = null, samplerIndex = null) {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) {
        return { success: false, error: 'No JMX file loaded' };
    }
    
    // Get thread group index from UI if not provided
    if (threadGroupIndex === null) {
        const tgSelect = document.getElementById('timerThreadGroup');
        if (!tgSelect || tgSelect.value === '') {
            return { success: false, error: 'Please select a thread group' };
        }
        threadGroupIndex = parseInt(tgSelect.value);
    }
    
    // Get sampler index from UI if not provided
    if (samplerIndex === null) {
        const samplerSelect = document.getElementById('timerSampler');
        samplerIndex = samplerSelect && samplerSelect.value !== '' ? parseInt(samplerSelect.value) : null;
    }
    
    const threadGroups = window.appState.threadGroupData || [];
    const samplers = window.appState.samplers || [];
    
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group selected' };
    }
    
    const threadGroup = threadGroups[threadGroupIndex];
    const tgHashTree = threadGroup.element.nextElementSibling;
    
    if (!tgHashTree || tgHashTree.tagName !== 'hashTree') {
        return { success: false, error: 'Invalid JMX structure - thread group has no hashTree' };
    }
    
    // Find target samplers
    let targetSamplers = [];
    
    if (samplerIndex !== null) {
        // Add to specific sampler
        const sampler = samplers.find(s => s.originalIndex === samplerIndex);
        if (sampler && tgHashTree.contains(sampler.element)) {
            targetSamplers.push(sampler);
        } else {
            return { success: false, error: 'Selected sampler not found in this thread group' };
        }
    } else {
        // Add to all samplers in this thread group
        samplers.forEach(sampler => {
            if (tgHashTree.contains(sampler.element)) {
                targetSamplers.push(sampler);
            }
        });
    }
    
    if (targetSamplers.length === 0) {
        return { success: false, error: 'No samplers found in selected thread group' };
    }
    
    let addedCount = 0;
    
    targetSamplers.forEach(sampler => {
        const samplerHashTree = sampler.element.nextElementSibling;
        
        if (!samplerHashTree || samplerHashTree.tagName !== 'hashTree') {
            return;
        }
        
        // Verify the samplerHashTree is part of the jmxDocument
        if (samplerHashTree.ownerDocument !== jmxDoc) {
            return;
        }
        
        // Create the timer element
        let timerElement;
        const timerName = name || `${type} - ${sampler.name}`;
        
        if (type === 'UniformRandomTimer') {
            timerElement = jmxDoc.createElement('UniformRandomTimer');
            timerElement.setAttribute('guiclass', 'UniformRandomTimerGui');
            timerElement.setAttribute('testclass', 'UniformRandomTimer');
            timerElement.setAttribute('testname', timerName);
            timerElement.setAttribute('enabled', 'true');
            
            const delayProp = jmxDoc.createElement('stringProp');
            delayProp.setAttribute('name', 'ConstantTimer.delay');
            delayProp.textContent = delay.toString();
            
            const rangeProp = jmxDoc.createElement('stringProp');
            rangeProp.setAttribute('name', 'RandomTimer.range');
            rangeProp.textContent = randomDelay.toString();
            
            timerElement.appendChild(delayProp);
            timerElement.appendChild(rangeProp);
            
        } else if (type === 'ConstantTimer') {
            timerElement = jmxDoc.createElement('ConstantTimer');
            timerElement.setAttribute('guiclass', 'ConstantTimerGui');
            timerElement.setAttribute('testclass', 'ConstantTimer');
            timerElement.setAttribute('testname', timerName);
            timerElement.setAttribute('enabled', 'true');
            
            const delayProp = jmxDoc.createElement('stringProp');
            delayProp.setAttribute('name', 'ConstantTimer.delay');
            delayProp.textContent = delay.toString();
            
            timerElement.appendChild(delayProp);
            
        } else if (type === 'GaussianRandomTimer') {
            timerElement = jmxDoc.createElement('GaussianRandomTimer');
            timerElement.setAttribute('guiclass', 'GaussianRandomTimerGui');
            timerElement.setAttribute('testclass', 'GaussianRandomTimer');
            timerElement.setAttribute('testname', timerName);
            timerElement.setAttribute('enabled', 'true');
            
            const offsetProp = jmxDoc.createElement('stringProp');
            offsetProp.setAttribute('name', 'ConstantTimer.delay');
            offsetProp.textContent = delay.toString();
            
            const deviationProp = jmxDoc.createElement('stringProp');
            deviationProp.setAttribute('name', 'RandomTimer.range');
            deviationProp.textContent = deviation.toString();
            
            timerElement.appendChild(offsetProp);
            timerElement.appendChild(deviationProp);
        }
        
        // Add timer to sampler's hashTree
        samplerHashTree.appendChild(timerElement);
        
        // Add empty hashTree after timer
        const emptyHashTree = jmxDoc.createElement('hashTree');
        samplerHashTree.appendChild(emptyHashTree);
        
        // Update state
        if (!window.appState.timers) {
            window.appState.timers = [];
        }
        
        window.appState.timers.push({
            element: timerElement,
            type: type,
            name: timerName,
            enabled: true,
            threadGroup: threadGroup.name,
            sampler: sampler.name
        });
        
        addedCount++;
    });
    
    return { success: true, addedCount: addedCount };
}

function deleteTimer(index) {
    const timers = window.appState.timers;
    if (!timers || index < 0 || index >= timers.length) {
        return { success: false, error: 'Invalid timer index' };
    }
    
    const timer = timers[index];
    const element = timer.element;
    
    // Remove timer and its hashTree from XML
    const hashTree = element.nextElementSibling;
    if (hashTree && hashTree.tagName === 'hashTree') {
        hashTree.remove();
    }
    element.remove();
    
    // Remove from state
    timers.splice(index, 1);
    
    return { success: true };
}

function toggleTimer(index) {
    const timers = window.appState.timers;
    if (!timers || index < 0 || index >= timers.length) {
        return { success: false, error: 'Invalid timer index' };
    }
    
    const timer = timers[index];
    const newStatus = !timer.enabled;
    
    timer.enabled = newStatus;
    timer.element.setAttribute('enabled', newStatus.toString());
    
    return { success: true };
}

function bulkAddThinkTime(delay, randomDelay, timerType = 'UniformRandomTimer') {
    const samplers = window.appState.samplers || [];
    if (samplers.length === 0) {
        return { success: false, error: 'No samplers found' };
    }
    
    let addedCount = 0;
    const jmxDoc = window.appState.jmxDocument;
    
    samplers.forEach((sampler, index) => {
        // Find the sampler's hashTree
        const samplerHashTree = sampler.element.nextElementSibling;
        if (!samplerHashTree || samplerHashTree.tagName !== 'hashTree') {
            return;
        }
        
        // Check if timer already exists in this sampler
        const existingTimers = samplerHashTree.querySelectorAll(timerType);
        if (existingTimers.length > 0) {
            return; // Skip if timer already exists
        }
        
        // Create timer
        let timerElement;
        const timerName = `Think Time - ${sampler.name}`;
        
        if (timerType === 'UniformRandomTimer') {
            timerElement = jmxDoc.createElement('UniformRandomTimer');
            timerElement.setAttribute('guiclass', 'UniformRandomTimerGui');
            timerElement.setAttribute('testclass', 'UniformRandomTimer');
            timerElement.setAttribute('testname', timerName);
            timerElement.setAttribute('enabled', 'true');
            
            const delayProp = jmxDoc.createElement('stringProp');
            delayProp.setAttribute('name', 'ConstantTimer.delay');
            delayProp.textContent = delay.toString();
            
            const rangeProp = jmxDoc.createElement('stringProp');
            rangeProp.setAttribute('name', 'RandomTimer.range');
            rangeProp.textContent = randomDelay.toString();
            
            timerElement.appendChild(delayProp);
            timerElement.appendChild(rangeProp);
            
        } else if (timerType === 'ConstantTimer') {
            timerElement = jmxDoc.createElement('ConstantTimer');
            timerElement.setAttribute('guiclass', 'ConstantTimerGui');
            timerElement.setAttribute('testclass', 'ConstantTimer');
            timerElement.setAttribute('testname', timerName);
            timerElement.setAttribute('enabled', 'true');
            
            const delayProp = jmxDoc.createElement('stringProp');
            delayProp.setAttribute('name', 'ConstantTimer.delay');
            delayProp.textContent = delay.toString();
            
            timerElement.appendChild(delayProp);
        }
        
        // Add to sampler's hashTree
        samplerHashTree.appendChild(timerElement);
        const emptyHashTree = jmxDoc.createElement('hashTree');
        samplerHashTree.appendChild(emptyHashTree);
        
        // Add to state
        if (!window.appState.timers) {
            window.appState.timers = [];
        }
        
        window.appState.timers.push({
            element: timerElement,
            type: timerType,
            name: timerName,
            enabled: true
        });
        
        addedCount++;
    });
    
    return { success: true, addedCount };
}


// Master Controller - Scenario & Slave Scaling
// Controls global scaling of thread groups and TPS

function initMasterController() {
    console.log('Master Controller initialized');
}

function calculatePerformanceSummary() {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) {
        return {
            activeGroups: 0,
            totalGroups: 0,
            originalUsers: 0,
            scaledUsers: 0,
            originalTPS: 0,
            scaledTPS: 0
        };
    }

    const masterScale = parseFloat(document.getElementById('masterScale').value) || 100;
    const slaveCount = parseInt(document.getElementById('slaveCount').value) || 1;
    const scaleMultiplier = masterScale / 100;

    // Get all thread groups
    const threadGroups = jmxDoc.getElementsByTagName('ThreadGroup');
    let totalGroups = threadGroups.length;
    let activeGroups = 0;
    let originalUsers = 0;
    let scaledUsers = 0;

    // Count active groups and users
    for (let i = 0; i < threadGroups.length; i++) {
        const tg = threadGroups[i];
        const enabled = tg.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            activeGroups++;
            
            // Get num_threads (user count) - check both intProp and stringProp
            let users = 0;
            const intProps = tg.getElementsByTagName('intProp');
            for (let j = 0; j < intProps.length; j++) {
                if (intProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                    users = parseInt(intProps[j].textContent) || 0;
                    break;
                }
            }
            if (users === 0) {
                const stringProps = tg.getElementsByTagName('stringProp');
                for (let j = 0; j < stringProps.length; j++) {
                    if (stringProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                        users = parseInt(stringProps[j].textContent) || 0;
                        break;
                    }
                }
            }
            originalUsers += users;
            scaledUsers += Math.round(users * scaleMultiplier);
        }
    }

    // Apply slave multiplier
    scaledUsers *= slaveCount;

    // Calculate TPS (simplified - would need precise throughput controller analysis)
    // For now, assume TPS scales linearly with users
    const originalTPS = calculateTPS();
    const scaledTPS = originalTPS * scaleMultiplier * slaveCount;

    return {
        activeGroups,
        totalGroups,
        originalUsers,
        scaledUsers,
        originalTPS: originalTPS.toFixed(2),
        scaledTPS: scaledTPS.toFixed(2)
    };
}

function calculateTPS() {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) return 0;

    // Look for Constant Throughput Timer or Precise Throughput Timer
    const constTimers = jmxDoc.getElementsByTagName('ConstantThroughputTimer');
    const preciseTimers = jmxDoc.getElementsByTagName('PreciseThroughputTimer');
    
    let totalTPS = 0;

    // Check Constant Throughput Timers
    for (let i = 0; i < constTimers.length; i++) {
        const props = constTimers[i].getElementsByTagName('doubleProp');
        for (let j = 0; j < props.length; j++) {
            if (props[j].getAttribute('name') === 'throughput') {
                // Throughput is in samples per minute, convert to TPS
                const samplesPerMinute = parseFloat(props[j].textContent) || 0;
                totalTPS += samplesPerMinute / 60;
                break;
            }
        }
    }

    // Check Precise Throughput Timers
    for (let i = 0; i < preciseTimers.length; i++) {
        const timer = preciseTimers[i];
        const enabled = timer.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            const doubleProps = timer.getElementsByTagName('doubleProp');
            for (let j = 0; j < doubleProps.length; j++) {
                const nameElement = doubleProps[j].getElementsByTagName('name')[0];
                if (nameElement && nameElement.textContent === 'throughput') {
                    const valueElement = doubleProps[j].getElementsByTagName('value')[0];
                    if (valueElement) {
                        const tps = parseFloat(valueElement.textContent) || 0;
                        totalTPS += tps;
                        break;
                    }
                }
            }
        }
    }

    // If no timers found, estimate based on users and avg response time
    if (totalTPS === 0) {
        const summary = calculateBasicMetrics();
        // Assume 1 second avg response time, users / response time = TPS
        totalTPS = summary.originalUsers / 1;
    }

    return totalTPS;
}

function calculateBasicMetrics() {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) return { originalUsers: 0 };

    const threadGroups = jmxDoc.getElementsByTagName('ThreadGroup');
    let originalUsers = 0;

    for (let i = 0; i < threadGroups.length; i++) {
        const tg = threadGroups[i];
        const enabled = tg.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            // Check both intProp and stringProp
            let users = 0;
            const intProps = tg.getElementsByTagName('intProp');
            for (let j = 0; j < intProps.length; j++) {
                if (intProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                    users = parseInt(intProps[j].textContent) || 0;
                    break;
                }
            }
            if (users === 0) {
                const stringProps = tg.getElementsByTagName('stringProp');
                for (let j = 0; j < stringProps.length; j++) {
                    if (stringProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                        users = parseInt(stringProps[j].textContent) || 0;
                        break;
                    }
                }
            }
            originalUsers += users;
        }
    }

    return { originalUsers };
}

function updatePerformanceSummary() {
    const summary = calculatePerformanceSummary();
    
    document.getElementById('activeGroups').textContent = `${summary.activeGroups} / ${summary.totalGroups}`;
    document.getElementById('originalUsers').textContent = summary.originalUsers;
    document.getElementById('scaledUsers').textContent = summary.scaledUsers;
    document.getElementById('originalTPS').textContent = summary.originalTPS;
    document.getElementById('scaledTPS').textContent = summary.scaledTPS;
}

function applyMasterScale() {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) {
        showToast('No JMX file loaded', 'error');
        return { success: false, error: 'No JMX file loaded' };
    }

    const masterScale = parseFloat(document.getElementById('masterScale').value) || 100;
    const scaleMultiplier = masterScale / 100;

    if (scaleMultiplier <= 0) {
        showToast('Scale percentage must be greater than 0', 'error');
        return { success: false, error: 'Invalid scale percentage' };
    }

    const threadGroups = jmxDoc.getElementsByTagName('ThreadGroup');
    const originalCounts = window.appState.originalThreadGroupCounts || [];
    let scaledCount = 0;

    // Scale all enabled thread groups
    for (let i = 0; i < threadGroups.length; i++) {
        const tg = threadGroups[i];
        const enabled = tg.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            // Scale num_threads in XML using ORIGINAL count as baseline
            // Check both intProp and stringProp
            let propElement = null;
            const intProps = tg.getElementsByTagName('intProp');
            for (let j = 0; j < intProps.length; j++) {
                if (intProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                    propElement = intProps[j];
                    break;
                }
            }
            if (!propElement) {
                const stringProps = tg.getElementsByTagName('stringProp');
                for (let j = 0; j < stringProps.length; j++) {
                    if (stringProps[j].getAttribute('name') === 'ThreadGroup.num_threads') {
                        propElement = stringProps[j];
                        break;
                    }
                }
            }
            
            if (propElement) {
                // Use original count from when file was loaded
                const originalUsers = originalCounts[i] || parseInt(propElement.textContent) || 0;
                const scaledUsers = Math.max(1, Math.round(originalUsers * scaleMultiplier));
                propElement.textContent = scaledUsers.toString();
                
                // Also update in appState.threadGroupData
                if (window.appState.threadGroupData && window.appState.threadGroupData[i]) {
                    window.appState.threadGroupData[i].count = scaledUsers;
                }
                
                scaledCount++;
            }
        }
    }

    // Update performance summary
    updatePerformanceSummary();

    showToast(`Scaled ${scaledCount} thread groups by ${masterScale}%`, 'success');
    return { success: true, scaledCount };
}

function setMasterScale(percentage) {
    document.getElementById('masterScale').value = percentage;
    updatePerformanceSummary();
}


// Workload Calculator - TPS Scaling & Little's Law
// Feature 5: Per-Thread-Group Calculate VUs, TPS, or Pacing



function initWorkloadCalculator() {
    console.log('Workload Calculator initialized');
}

// Get TPS from Performance Summary calculation (same logic)
function getPerformanceSummaryTPS() {
    const jmxDoc = window.appState.jmxDocument;
    if (!jmxDoc) return 0;

    // Look for timers
    const constTimers = jmxDoc.getElementsByTagName('ConstantThroughputTimer');
    const preciseTimers = jmxDoc.getElementsByTagName('PreciseThroughputTimer');
    
    let totalTPS = 0;

    // Check Constant Throughput Timers
    for (let i = 0; i < constTimers.length; i++) {
        const props = constTimers[i].getElementsByTagName('doubleProp');
        for (let j = 0; j < props.length; j++) {
            if (props[j].getAttribute('name') === 'throughput') {
                const samplesPerMinute = parseFloat(props[j].textContent) || 0;
                totalTPS += samplesPerMinute / 60;
                break;
            }
        }
    }

    // Check Precise Throughput Timers
    for (let i = 0; i < preciseTimers.length; i++) {
        const timer = preciseTimers[i];
        const enabled = timer.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            const doubleProps = timer.getElementsByTagName('doubleProp');
            for (let j = 0; j < doubleProps.length; j++) {
                const nameElement = doubleProps[j].getElementsByTagName('name')[0];
                if (nameElement && nameElement.textContent === 'throughput') {
                    const valueElement = doubleProps[j].getElementsByTagName('value')[0];
                    if (valueElement) {
                        const tps = parseFloat(valueElement.textContent) || 0;
                        totalTPS += tps;
                        break;
                    }
                }
            }
        }
    }

    // If no timers, estimate: TPS = Users / 1 second iteration time
    if (totalTPS === 0) {
        const threadGroups = window.appState.threadGroupData || [];
        let totalUsers = 0;
        threadGroups.forEach(tg => totalUsers += tg.count);
        totalTPS = totalUsers / 1; // Same as Performance Summary
    }

    return totalTPS;
}

function renderScalingTable() {
    const threadGroups = window.appState.threadGroupData || [];
    const container = document.getElementById('scalingTableContainer');
    
    if (threadGroups.length === 0) {
        container.innerHTML = `
            <div class="text-center py-12 text-gray-500">
                <p class="mb-2">No thread groups found</p>
                <p class="text-sm">Load a JMX file to begin workload calculations</p>
            </div>
        `;
        return;
    }
    
    // Get total TPS from Performance Summary method
    const totalCurrentTPS = getPerformanceSummaryTPS();
    
    // Calculate total users
    let totalCurrentUsers = 0;
    threadGroups.forEach(tg => {
        totalCurrentUsers += tg.count;
    });
    
    let html = `
        <!-- Global TPS Input -->
        <div class="bg-gray-50 border border-gray-300 rounded-lg p-4 mb-4">
            <div class="grid grid-cols-3 gap-4 items-center">
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Current Total TPS</label>
                    <div class="text-2xl font-bold text-gray-900">${totalCurrentTPS.toFixed(2)}</div>
                    <div class="text-xs text-gray-500">${totalCurrentUsers} total users</div>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Target Total TPS</label>
                    <input type="number" id="target-total-tps" value="${totalCurrentTPS.toFixed(2)}" min="0.1" step="0.1"
                        class="w-full px-3 py-2 border border-gray-300 rounded text-center text-lg focus:ring-2 focus:ring-green-500">
                </div>
                <div>
                    <button onclick="calculateScalingFactor()" 
                        class="w-full px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium">
                        Calculate Scaling
                    </button>
                </div>
            </div>
            <div id="scaling-result" class="mt-4 text-center hidden">
                <div class="text-sm text-gray-600">Scaling Factor: <span id="scaling-factor" class="font-bold text-green-600 text-xl"></span></div>
            </div>
        </div>

        <!-- Per Thread Group Results -->
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-3 py-3 text-left text-xs font-medium text-gray-700 uppercase">Thread Group</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Current Users</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Current TPS</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Scaled Users</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Scaled TPS</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
    `;
    
    threadGroups.forEach((tg, index) => {
        // Distribute total TPS proportionally based on user count
        const tgProportion = tg.count / totalCurrentUsers;
        const tgTPS = totalCurrentTPS * tgProportion;
        
        html += `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-3 py-3 text-sm font-medium text-gray-900">${tg.name}</td>
                <td class="px-3 py-3 text-sm text-center text-gray-700">${tg.count}</td>
                <td class="px-3 py-3 text-sm text-center text-gray-700">${tgTPS.toFixed(2)}</td>
                <td class="px-3 py-3 text-sm text-center">
                    <span id="scaled-users-${index}" class="font-semibold text-green-600">-</span>
                </td>
                <td class="px-3 py-3 text-sm text-center">
                    <span id="scaled-tps-${index}" class="font-semibold text-green-600">-</span>
                </td>
            </tr>
        `;
    });
    
    html += `
            </tbody>
        </table>
        
        <div class="mt-4">
            <button onclick="applyScaledValues()" 
                class="w-full px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors font-medium">
                Apply Scaled Values to All Thread Groups
            </button>
        </div>
        
        <!-- Individual TPS Adjustment Section -->
        <div class="mt-8 border-t border-gray-300 pt-6">
            <h4 class="text-md font-bold text-gray-900 mb-4">üìù Individual TPS Adjustment</h4>
            <p class="text-sm text-gray-600 mb-4">Adjust TPS for each thread group independently</p>
            <div id="individualTPSContainer"></div>
        </div>
    `;
    
    container.innerHTML = html;
    
    // Render individual TPS adjustment cards
    renderIndividualTPSCards();
}

function renderIndividualTPSCards() {
    const threadGroups = window.appState.threadGroupData || [];
    const container = document.getElementById('individualTPSContainer');
    
    if (!container) return;
    
    const totalTPS = getPerformanceSummaryTPS();
    const totalUsers = threadGroups.reduce((sum, tg) => sum + tg.count, 0);
    
    let html = '';
    threadGroups.forEach((tg, index) => {
        const tgProportion = tg.count / totalUsers;
        const currentTPS = totalTPS * tgProportion;
        
        html += `
            <div class="bg-white border border-gray-300 rounded-lg p-4 mb-3">
                <div class="flex items-center justify-between mb-3">
                    <h5 class="text-sm font-bold text-gray-900">${tg.name}</h5>
                    <span class="text-xs text-gray-500">TPS/User: ${(currentTPS / tg.count).toFixed(4)}</span>
                </div>
                <div class="grid grid-cols-4 gap-3 items-end">
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Current Users</label>
                        <div class="text-lg font-bold text-gray-900">${tg.count}</div>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Current TPS</label>
                        <div class="text-lg font-bold text-gray-900">${currentTPS.toFixed(2)}</div>
                    </div>
                    <div>
                        <label class="block text-xs font-medium text-gray-600 mb-1">Target TPS</label>
                        <input type="number" id="individual-tps-${index}" value="${currentTPS.toFixed(2)}" min="0.1" step="0.1"
                            class="w-full px-2 py-1 text-sm border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div>
                        <button onclick="calculateAndApplyIndividualTPS(${index})" 
                            class="w-full px-4 py-2 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors font-medium">
                            Calculate & Apply
                        </button>
                    </div>
                </div>
            </div>
        `;
    });
    
    container.innerHTML = html;
}

function renderWorkloadTable() {
    console.log('renderWorkloadTable called');
    const threadGroups = window.appState.threadGroupData || [];
    const container = document.getElementById('workloadTableContainer');
    
    console.log('threadGroups:', threadGroups.length);
    console.log('container:', container);
    
    if (threadGroups.length === 0) {
        container.innerHTML = `
            <div class="text-center py-12 text-gray-500">
                <p class="mb-2">No thread groups found</p>
                <p class="text-sm">Load a JMX file to begin workload calculations</p>
            </div>
        `;
        return;
    }
    
    let html = `
        <table class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
                <tr>
                    <th class="px-3 py-3 text-left text-xs font-medium text-gray-700 uppercase">Thread Group</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Current Users</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Calc Users</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Current TPS</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Target TPS</th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Total RT<span class="normal-case">(s)</span></th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Total TT<span class="normal-case">(s)</span></th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Pacing<span class="normal-case">(s)</span></th>
                    <th class="px-3 py-3 text-center text-xs font-medium text-gray-700 uppercase">Actions</th>
                </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
    `;
    
    threadGroups.forEach((tg, index) => {
        const currentTPS = getCurrentTPS(tg);
        
        html += `
            <tr class="hover:bg-gray-50 transition-colors">
                <td class="px-3 py-3 text-sm font-medium text-gray-900">${tg.name}</td>
                <td class="px-3 py-3 text-sm text-center text-gray-700">${tg.count}</td>
                <td class="px-3 py-3 text-sm text-center">
                    <span id="calc-users-${index}" class="font-semibold text-blue-600">-</span>
                </td>
                <td class="px-3 py-3 text-sm text-center text-gray-700">${currentTPS.toFixed(2)}</td>
                <td class="px-3 py-3 text-center">
                    <input type="number" id="tps-${index}" value="${currentTPS.toFixed(2)}" min="0.1" step="0.1"
                        class="w-20 px-2 py-1 text-sm border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500">
                </td>
                <td class="px-3 py-3 text-center">
                    <input type="number" id="rt-${index}" value="10" min="0" step="0.1" 
                        class="w-16 px-2 py-1 text-sm border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500">
                </td>
                <td class="px-3 py-3 text-center">
                    <input type="number" id="tt-${index}" value="12" min="0" step="0.1" 
                        class="w-16 px-2 py-1 text-sm border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500">
                </td>
                <td class="px-3 py-3 text-center">
                    <input type="number" id="pacing-${index}" value="0" min="0" step="0.1" 
                        class="w-16 px-2 py-1 text-sm border border-gray-300 rounded text-center focus:ring-2 focus:ring-blue-500">
                </td>
                <td class="px-3 py-3 text-center">
                    <div class="flex flex-col gap-1">
                        <button onclick="calculateUsersOnly(${index})" 
                            class="px-3 py-1 text-xs bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors font-medium whitespace-nowrap">
                            Calc Users
                        </button>
                        <button onclick="calculateTPSForThreadGroup(${index})" 
                            class="px-3 py-1 text-xs bg-purple-600 text-white rounded hover:bg-purple-700 transition-colors font-medium whitespace-nowrap">
                            Calc TPS
                        </button>
                        <button onclick="calculatePacingForThreadGroup(${index})" 
                            class="px-3 py-1 text-xs bg-orange-600 text-white rounded hover:bg-orange-700 transition-colors font-medium whitespace-nowrap">
                            Calc Pacing
                        </button>
                        <button onclick="applyCalculatedValues(${index})" 
                            class="px-3 py-1 text-xs bg-green-600 text-white rounded hover:bg-green-700 transition-colors font-medium whitespace-nowrap">
                            Apply All
                        </button>
                    </div>
                </td>
            </tr>
        `;
    });
    
    html += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = html;
}

// Get current TPS from throughput timers for a thread group
function getCurrentTPS(threadGroup) {
    const tgHashTree = threadGroup.element.parentElement;
    let totalTPS = 0;
    
    // Check for Precise Throughput Timers (search entire subtree)
    const preciseTimers = tgHashTree.getElementsByTagName('kg.apc.jmeter.timers.VariableThroughputTimer');
    for (let i = 0; i < preciseTimers.length; i++) {
        const timer = preciseTimers[i];
        const enabled = timer.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            const doubleProps = timer.getElementsByTagName('doubleProp');
            for (let j = 0; j < doubleProps.length; j++) {
                const prop = doubleProps[j];
                // Check for simple format: <doubleProp name="throughput">value</doubleProp>
                if (prop.getAttribute('name') === 'throughput') {
                    const directValue = parseFloat(prop.textContent) || 0;
                    if (directValue > 0) {
                        totalTPS += directValue;
                        break;
                    }
                }
                
                // Check for nested format: <doubleProp><name>throughput</name><value>X</value></doubleProp>
                const nameElement = prop.getElementsByTagName('name')[0];
                if (nameElement && nameElement.textContent === 'throughput') {
                    const valueElement = prop.getElementsByTagName('value')[0];
                    if (valueElement) {
                        totalTPS += parseFloat(valueElement.textContent) || 0;
                        break;
                    }
                }
            }
        }
    }
    
    // Check for Constant Throughput Timers (search entire subtree)
    const constTimers = tgHashTree.getElementsByTagName('ConstantThroughputTimer');
    for (let i = 0; i < constTimers.length; i++) {
        const timer = constTimers[i];
        const enabled = timer.getAttribute('enabled') !== 'false';
        
        if (enabled) {
            const doubleProps = timer.getElementsByTagName('doubleProp');
            for (let j = 0; j < doubleProps.length; j++) {
                if (doubleProps[j].getAttribute('name') === 'throughput') {
                    const samplesPerMinute = parseFloat(doubleProps[j].textContent) || 0;
                    totalTPS += samplesPerMinute / 60; // Convert to TPS
                    break;
                }
            }
        }
    }
    
    return totalTPS;
}

function calculateUsersOnly(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    // Get input values
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    const totalRT = parseFloat(document.getElementById(`rt-${threadGroupIndex}`).value);
    const totalTT = parseFloat(document.getElementById(`tt-${threadGroupIndex}`).value);
    const pacing = parseFloat(document.getElementById(`pacing-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (isNaN(targetTPS) || targetTPS <= 0) {
        return { success: false, error: 'Target TPS must be greater than 0' };
    }
    if (isNaN(totalRT) || totalRT < 0 || isNaN(totalTT) || totalTT < 0 || isNaN(pacing) || pacing < 0) {
        return { success: false, error: 'Response time, think time, and pacing cannot be negative' };
    }
    
    // Calculate virtual users
    const result = calculateVirtualUsers(targetTPS, totalRT, totalTT, pacing);
    const calculatedUsers = Math.ceil(result.vus);
    
    // Display in Calc Users column (don't apply yet)
    document.getElementById(`calc-users-${threadGroupIndex}`).textContent = calculatedUsers;
    document.getElementById(`calc-users-${threadGroupIndex}`).classList.add('text-green-600', 'font-bold');
    
    return { 
        success: true, 
        users: calculatedUsers,
        breakdown: result.breakdown,
        iterationTime: result.iterationTime
    };
}

function applyCalculatedValues(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    // Get calculated users value
    const calcUsersText = document.getElementById(`calc-users-${threadGroupIndex}`).textContent;
    const calculatedUsers = parseInt(calcUsersText);
    
    if (isNaN(calculatedUsers) || calculatedUsers < 1 || calcUsersText === '-') {
        return { success: false, error: 'Calculate users first before applying' };
    }
    
    // Apply users to thread group
    const threadGroup = threadGroups[threadGroupIndex];
    threadGroup.count = calculatedUsers;
    
    const intProps = threadGroup.element.getElementsByTagName('intProp');
    for (let i = 0; i < intProps.length; i++) {
        if (intProps[i].getAttribute('name') === 'ThreadGroup.num_threads') {
            intProps[i].textContent = calculatedUsers.toString();
            break;
        }
    }
    
    // Apply TPS
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    if (!isNaN(targetTPS) && targetTPS > 0) {
        const jmxDoc = window.appState.jmxDocument;
        addOrUpdateThroughputTimer(threadGroup, targetTPS, jmxDoc);
    }
    
    return { success: true, users: calculatedUsers, tps: targetTPS };
}

function calculateAndApplyVirtualUsers(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    // Get input values
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    const totalRT = parseFloat(document.getElementById(`rt-${threadGroupIndex}`).value);
    const totalTT = parseFloat(document.getElementById(`tt-${threadGroupIndex}`).value);
    const pacing = parseFloat(document.getElementById(`pacing-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (isNaN(targetTPS) || targetTPS <= 0) {
        return { success: false, error: 'Target TPS must be greater than 0' };
    }
    if (isNaN(totalRT) || totalRT < 0 || isNaN(totalTT) || totalTT < 0 || isNaN(pacing) || pacing < 0) {
        return { success: false, error: 'Response time, think time, and pacing cannot be negative' };
    }
    
    // Calculate virtual users
    const result = calculateVirtualUsers(targetTPS, totalRT, totalTT, pacing);
    const calculatedUsers = Math.ceil(result.vus);
    
    // Apply to thread group
    const threadGroup = threadGroups[threadGroupIndex];
    threadGroup.count = calculatedUsers;
    
    const intProps = threadGroup.element.getElementsByTagName('intProp');
    for (let i = 0; i < intProps.length; i++) {
        if (intProps[i].getAttribute('name') === 'ThreadGroup.num_threads') {
            intProps[i].textContent = calculatedUsers.toString();
            break;
        }
    }
    
    return { 
        success: true, 
        users: calculatedUsers,
        breakdown: result.breakdown,
        iterationTime: result.iterationTime
    };
}

function calculateTPSForThreadGroup(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    const threadGroup = threadGroups[threadGroupIndex];
    
    // Get input values - use calculated users if available, otherwise current users
    const calcUsersSpan = document.getElementById(`calc-users-${threadGroupIndex}`);
    const calcUsers = calcUsersSpan && calcUsersSpan.textContent !== '-' ? parseInt(calcUsersSpan.textContent) : null;
    const currentUsers = calcUsers || threadGroup.count;
    const totalRT = parseFloat(document.getElementById(`rt-${threadGroupIndex}`).value);
    const totalTT = parseFloat(document.getElementById(`tt-${threadGroupIndex}`).value);
    const pacing = parseFloat(document.getElementById(`pacing-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (currentUsers < 1) {
        return { success: false, error: 'Current users must be at least 1' };
    }
    if (isNaN(totalRT) || totalRT < 0 || isNaN(totalTT) || totalTT < 0 || isNaN(pacing) || pacing < 0) {
        return { success: false, error: 'Response time, think time, and pacing cannot be negative' };
    }
    
    // Calculate TPS
    const result = calculateTPS(currentUsers, totalRT, totalTT, pacing);
    const calculatedTPS = result.tps;
    
    // Update Target TPS field
    document.getElementById(`tps-${threadGroupIndex}`).value = calculatedTPS.toFixed(2);
    
    return { 
        success: true, 
        tps: calculatedTPS,
        breakdown: result.breakdown,
        iterationTime: result.iterationTime
    };
}

function calculatePacingForThreadGroup(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    const threadGroup = threadGroups[threadGroupIndex];
    
    // Get input values - use calculated users if available, otherwise current users
    const calcUsersSpan = document.getElementById(`calc-users-${threadGroupIndex}`);
    const calcUsers = calcUsersSpan && calcUsersSpan.textContent !== '-' ? parseInt(calcUsersSpan.textContent) : null;
    const currentUsers = calcUsers || threadGroup.count;
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    const totalRT = parseFloat(document.getElementById(`rt-${threadGroupIndex}`).value);
    const totalTT = parseFloat(document.getElementById(`tt-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (currentUsers < 1) {
        return { success: false, error: 'Current users must be at least 1' };
    }
    if (isNaN(targetTPS) || targetTPS <= 0) {
        return { success: false, error: 'Target TPS must be greater than 0' };
    }
    if (isNaN(totalRT) || totalRT < 0 || isNaN(totalTT) || totalTT < 0) {
        return { success: false, error: 'Response time and think time cannot be negative' };
    }
    
    // Calculate Pacing
    const result = calculatePacing(currentUsers, targetTPS, totalRT, totalTT);
    const calculatedPacing = result.pacing;
    
    // Update Pacing field
    document.getElementById(`pacing-${threadGroupIndex}`).value = calculatedPacing.toFixed(2);
    
    return { 
        success: true, 
        pacing: calculatedPacing,
        breakdown: result.breakdown,
        iterationTime: result.iterationTime
    };
}

function applyTPSToThreadGroup(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    // Get input values
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (isNaN(targetTPS) || targetTPS <= 0) {
        return { success: false, error: 'Target TPS must be greater than 0' };
    }
    
    const threadGroup = threadGroups[threadGroupIndex];
    const jmxDoc = window.appState.jmxDocument;
    
    // Smart detection and update
    const result = addOrUpdateThroughputTimer(threadGroup, targetTPS, jmxDoc);
    
    return result;
}

function calculateAndApplyTPS(threadGroupIndex) {
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        return { success: false, error: 'Invalid thread group index' };
    }
    
    // Get input values
    const targetTPS = parseFloat(document.getElementById(`tps-${threadGroupIndex}`).value);
    
    // Validate inputs
    if (isNaN(targetTPS) || targetTPS <= 0) {
        return { success: false, error: 'Target TPS must be greater than 0' };
    }
    
    const threadGroup = threadGroups[threadGroupIndex];
    const jmxDoc = window.appState.jmxDocument;
    
    // Smart detection and update
    const result = addOrUpdateThroughputTimer(threadGroup, targetTPS, jmxDoc);
    
    return result;
}

function addOrUpdateThroughputTimer(threadGroup, targetTPS, jmxDoc) {
    const tgElement = threadGroup.element;
    const tgHashTree = tgElement.nextElementSibling;
    
    if (!tgHashTree || tgHashTree.tagName !== 'hashTree') {
        return { success: false, error: 'Invalid thread group structure' };
    }
    
    // Check for existing throughput timers (ignore think time timers)
    let existingTimer = null;
    let timerType = null;
    
    // Check for Precise Throughput Timer
    const preciseTimers = tgHashTree.getElementsByTagName('PreciseThroughputTimer');
    if (preciseTimers.length > 0) {
        existingTimer = preciseTimers[0];
        timerType = 'PreciseThroughputTimer';
    }
    
    // Check for Constant Throughput Timer
    if (!existingTimer) {
        const constTimers = tgHashTree.getElementsByTagName('ConstantThroughputTimer');
        if (constTimers.length > 0) {
            existingTimer = constTimers[0];
            timerType = 'ConstantThroughputTimer';
        }
    }
    
    if (existingTimer) {
        // UPDATE existing timer
        if (timerType === 'PreciseThroughputTimer') {
            const doubleProps = existingTimer.getElementsByTagName('doubleProp');
            let updated = false;
            
            for (let i = 0; i < doubleProps.length; i++) {
                const prop = doubleProps[i];
                
                // Check for simple format: <doubleProp name="throughput">value</doubleProp>
                if (prop.getAttribute('name') === 'throughput') {
                    // Check if it has nested structure
                    const valueElement = prop.getElementsByTagName('value')[0];
                    if (valueElement) {
                        // Nested format: update <value> element
                        valueElement.textContent = targetTPS.toString();
                    } else {
                        // Simple format: update direct text content
                        prop.textContent = targetTPS.toString();
                    }
                    updated = true;
                    break;
                }
            }
            
            if (updated) {
                return { success: true, action: 'updated', tps: targetTPS };
            }
        } else if (timerType === 'ConstantThroughputTimer') {
            const doubleProps = existingTimer.getElementsByTagName('doubleProp');
            for (let i = 0; i < doubleProps.length; i++) {
                if (doubleProps[i].getAttribute('name') === 'throughput') {
                    const samplesPerMinute = targetTPS * 60;
                    doubleProps[i].textContent = samplesPerMinute.toString();
                    return { success: true, action: 'updated', tps: targetTPS };
                }
            }
        }
    }
    
    // ADD new Precise Throughput Timer
    const timer = jmxDoc.createElement('PreciseThroughputTimer');
    timer.setAttribute('guiclass', 'TestBeanGUI');
    timer.setAttribute('testclass', 'PreciseThroughputTimer');
    timer.setAttribute('testname', `TPS Controller - ${threadGroup.name}`);
    timer.setAttribute('enabled', 'true');
    
    // Throughput (TPS)
    const throughputProp = jmxDoc.createElement('doubleProp');
    throughputProp.setAttribute('name', 'throughput');
    throughputProp.textContent = targetTPS.toString();
    
    // Throughput period (seconds)
    const periodProp = jmxDoc.createElement('intProp');
    periodProp.setAttribute('name', 'throughputPeriod');
    periodProp.textContent = '3600';
    
    // Test duration (seconds)
    const durationProp = jmxDoc.createElement('longProp');
    durationProp.setAttribute('name', 'duration');
    durationProp.textContent = '3600';
    
    // Random seed
    const seedProp = jmxDoc.createElement('longProp');
    seedProp.setAttribute('name', 'randomSeed');
    seedProp.textContent = '0';
    
    // Exact limit
    const exactLimitProp = jmxDoc.createElement('intProp');
    exactLimitProp.setAttribute('name', 'exactLimit');
    exactLimitProp.textContent = '10000';
    
    timer.appendChild(throughputProp);
    timer.appendChild(periodProp);
    timer.appendChild(durationProp);
    timer.appendChild(seedProp);
    timer.appendChild(exactLimitProp);
    
    // Add timer to thread group hashTree
    tgHashTree.appendChild(timer);
    
    // Add empty hashTree after timer
    const emptyHashTree = jmxDoc.createElement('hashTree');
    tgHashTree.appendChild(emptyHashTree);
    
    return { success: true, action: 'added', tps: targetTPS };
}

// TPS Scaling Calculator Functions
function calculateScalingFactor() {
    const threadGroups = window.appState.threadGroupData || [];
    const targetTotalTPS = parseFloat(document.getElementById('target-total-tps').value);
    
    if (isNaN(targetTotalTPS) || targetTotalTPS <= 0) {
        alert('Please enter a valid target TPS');
        return;
    }
    
    // Get total current TPS from Performance Summary method
    const totalCurrentTPS = getPerformanceSummaryTPS();
    
    if (totalCurrentTPS === 0) {
        alert('Current TPS is 0. Cannot calculate scaling factor.');
        return;
    }
    
    // Calculate total users
    let totalCurrentUsers = 0;
    threadGroups.forEach(tg => totalCurrentUsers += tg.count);
    
    // Calculate scaling factor
    const scalingFactor = targetTotalTPS / totalCurrentTPS;
    
    // Display scaling factor
    document.getElementById('scaling-factor').textContent = scalingFactor.toFixed(2) + 'x';
    document.getElementById('scaling-result').classList.remove('hidden');
    
    // Calculate and display scaled values for each thread group
    threadGroups.forEach((tg, index) => {
        // Current TPS distributed proportionally
        const tgProportion = tg.count / totalCurrentUsers;
        const currentTPS = totalCurrentTPS * tgProportion;
        
        const scaledUsers = Math.ceil(tg.count * scalingFactor);
        const scaledTPS = currentTPS * scalingFactor;
        
        document.getElementById(`scaled-users-${index}`).textContent = scaledUsers;
        document.getElementById(`scaled-tps-${index}`).textContent = scaledTPS.toFixed(2);
    });
}

function applyScaledValues() {
    const threadGroups = window.appState.threadGroupData || [];
    const targetTotalTPS = parseFloat(document.getElementById('target-total-tps').value);
    
    if (isNaN(targetTotalTPS) || targetTotalTPS <= 0) {
        alert('Please calculate scaling first');
        return;
    }
    
    // Get total current TPS
    const totalCurrentTPS = getPerformanceSummaryTPS();
    const scalingFactor = targetTotalTPS / totalCurrentTPS;
    
    // Calculate total users
    let totalCurrentUsers = 0;
    threadGroups.forEach(tg => totalCurrentUsers += tg.count);
    
    // Apply scaled values to all thread groups
    let appliedCount = 0;
    threadGroups.forEach((tg, index) => {
        // Current TPS distributed proportionally
        const tgProportion = tg.count / totalCurrentUsers;
        const currentTPS = totalCurrentTPS * tgProportion;
        
        const scaledUsers = Math.ceil(tg.count * scalingFactor);
        const scaledTPS = currentTPS * scalingFactor;
        
        // Update users in thread group
        tg.count = scaledUsers;
        const intProps = tg.element.getElementsByTagName('intProp');
        for (let i = 0; i < intProps.length; i++) {
            if (intProps[i].getAttribute('name') === 'ThreadGroup.num_threads') {
                intProps[i].textContent = scaledUsers.toString();
                break;
            }
        }
        
        // Update TPS timer
        const jmxDoc = window.appState.jmxDocument;
        addOrUpdateThroughputTimer(tg, scaledTPS, jmxDoc);
        
        appliedCount++;
    });
    
    alert(`Applied scaling to ${appliedCount} thread groups!`);
    
    // Refresh tables - these are global window functions
    if (typeof window.renderThreadGroupsTable === 'function') {
        window.renderThreadGroupsTable();
    }
    renderScalingTable();
}

/**
 * Calculate and apply individual TPS adjustment for a specific thread group
 */
function calculateAndApplyIndividualTPS(threadGroupIndex) {
    if (!window.appState?.jmxData) {
        alert('No JMX file loaded');
        return;
    }
    
    const threadGroups = window.appState.threadGroupData || [];
    if (threadGroupIndex < 0 || threadGroupIndex >= threadGroups.length) {
        alert('Invalid thread group index');
        return;
    }
    
    const targetTPS = parseFloat(document.getElementById(`individual-tps-${threadGroupIndex}`).value);
    if (!targetTPS || targetTPS <= 0) {
        alert('Please enter a valid target TPS');
        return;
    }
    
    const tg = threadGroups[threadGroupIndex];
    const totalTPS = getPerformanceSummaryTPS();
    const totalUsers = threadGroups.reduce((sum, tg) => sum + tg.count, 0);
    
    // Calculate current TPS for this thread group (proportional distribution)
    const tgProportion = tg.count / totalUsers;
    const currentTPS = totalTPS * tgProportion;
    
    // Calculate scaling factor for this thread group
    const scalingFactor = targetTPS / currentTPS;
    const newUsers = Math.ceil(tg.count * scalingFactor);
    
    if (!confirm(`Thread Group: ${tg.name}\nCurrent Users: ${tg.count}\nCurrent TPS: ${currentTPS.toFixed(2)}\nTarget TPS: ${targetTPS.toFixed(2)}\nScaling Factor: ${scalingFactor.toFixed(2)}x\nNew Users: ${newUsers}\n\nApply this change?`)) {
        return;
    }
    
    // Update the thread group count
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(window.appState.jmxData, 'text/xml');
    const allThreadGroups = xmlDoc.querySelectorAll('ThreadGroup, com.blazemeter.jmeter.threads.concurrency.ConcurrencyThreadGroup, com.octoperf.jmeter.OctoPerfThreadGroup');
    
    if (threadGroupIndex < allThreadGroups.length) {
        const tgElement = allThreadGroups[threadGroupIndex];
        
        // Update thread count
        const numThreadsElement = tgElement.querySelector('stringProp[name="ThreadGroup.num_threads"]');
        if (numThreadsElement) {
            numThreadsElement.textContent = newUsers.toString();
        }
        
        // Update concurrency thread group count
        const targetConcurrencyElement = tgElement.querySelector('stringProp[name="TargetLevel"]');
        if (targetConcurrencyElement) {
            targetConcurrencyElement.textContent = newUsers.toString();
        }
        
        // Serialize and update
        const serializer = new XMLSerializer();
        window.appState.jmxData = serializer.serializeToString(xmlDoc);
        
        // Update thread group data
        window.appState.threadGroupData[threadGroupIndex].count = newUsers;
        
        alert(`Successfully updated ${tg.name} to ${newUsers} users!`);
        
        // Refresh all displays
        if (typeof window.renderThreadGroupsTable === 'function') {
            window.renderThreadGroupsTable();
        }
        if (typeof window.updatePerformanceSummary === 'function') {
            window.updatePerformanceSummary();
        }
        renderScalingTable();
        renderIndividualTPSCards();
    }
}


// Main Application Controller









// Global state
window.appState = {
    jmxDocument: null,
    threadGroupData: [],
    originalThreadGroupCounts: [],
    globalVariables: { rampup: "N/A", steadyState: "N/A" },
    samplers: [],
    csvConfigs: [],
    timers: [],
    userDefinedVariables: [],
    userDefinedVariablesElement: null,
    calculatedWorkload: null,
    isOnline: navigator.onLine
};

// Network Status Monitoring
function updateNetworkStatus() {
    const isOnline = navigator.onLine;
    window.appState.isOnline = isOnline;
    
    const statusDot = document.getElementById('statusDot');
    const statusText = document.getElementById('statusText');
    
    if (!statusDot || !statusText) return;
    
    if (isOnline) {
        statusDot.className = 'w-2 h-2 bg-green-500 rounded-full animate-pulse';
        statusDot.title = 'Online - Application Ready';
        statusText.textContent = 'Ready';
        statusText.className = 'text-xs font-medium text-green-600';
    } else {
        statusDot.className = 'w-2 h-2 bg-red-500 rounded-full';
        statusDot.title = 'Offline - No Internet Connection';
        statusText.textContent = 'Offline';
        statusText.className = 'text-xs font-medium text-red-600';
    }
}

// Listen for network status changes
window.addEventListener('online', updateNetworkStatus);
window.addEventListener('offline', updateNetworkStatus);

// Initialize network status on load
document.addEventListener('DOMContentLoaded', updateNetworkStatus);

// File upload handler
document.getElementById('fileInput').addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(event) {
        try {
            const result = parseJMX(event.target.result);
            
            if (result.error) {
                showToast(result.error, 'error');
                return;
            }
            
            // Update global state
            window.appState = { ...window.appState, ...result };
            
            // Store original thread group counts for master scaling
            window.appState.originalThreadGroupCounts = result.threadGroupData.map(tg => tg.count);
            
            // Show main content
            document.getElementById('uploadPrompt').style.display = 'none';
            document.getElementById('mainContent').style.display = 'block';
            document.getElementById('downloadBtn').disabled = false;
            
            // Render initial view
            try {
                renderThreadGroupsTable();
                console.log('‚úì Thread groups rendered');
            } catch (err) {
                console.error('Error rendering thread groups:', err);
            }
            
            try {
                renderVariablesTable();
                console.log('‚úì Variables rendered');
            } catch (err) {
                console.error('Error rendering variables:', err);
            }
            
            try {
                renderSamplersTable();
                console.log('‚úì Samplers rendered');
            } catch (err) {
                console.error('Error rendering samplers:', err);
            }
            
            try {
                renderTimersTable();
                console.log('‚úì Timers rendered');
            } catch (err) {
                console.error('Error rendering timers:', err);
            }
            
            try {
                populateTimerDropdowns();
                console.log('‚úì Timer dropdowns populated');
            } catch (err) {
                console.error('Error populating timer dropdowns:', err);
            }
            
            try {
                renderCSVTable();
                console.log('‚úì CSV rendered');
            } catch (err) {
                console.error('Error rendering CSV:', err);
            }
            
            try {
                renderScalingTable();
                console.log('‚úì Scaling table rendered');
            } catch (err) {
                console.error('Error rendering scaling table:', err);
            }
            
            try {
                renderWorkloadTable();
                console.log('‚úì Workload table rendered');
            } catch (err) {
                console.error('Error rendering workload table:', err);
            }
            
            try {
                updatePerformanceSummary();
                console.log('‚úì Performance summary updated');
            } catch (err) {
                console.error('Error updating performance summary:', err);
            }
            
            showToast('JMX loaded successfully!', 'success');
        } catch (error) {
            console.error('Parse error:', error);
            showToast('Failed to parse JMX file', 'error');
        }
    };
    reader.readAsText(file);
});

// Tab switching
window.switchTab = function(tabName) {
    // Hide all tab contents
    document.querySelectorAll('.tab-content').forEach(el => el.style.display = 'none');
    // Remove active class from all tabs
    document.querySelectorAll('[id^="tab-"]').forEach(el => el.classList.remove('tab-active'));
    // Show selected tab
    document.getElementById(`content-${tabName}`).style.display = 'block';
    document.getElementById(`tab-${tabName}`).classList.add('tab-active');
};

// Download JMX
window.downloadJMX = function() {
    const result = downloadModifiedJMX();
    if (result.success) {
        showToast('JMX downloaded!', 'success');
    } else {
        showToast('Download failed: ' + result.error, 'error');
    }
};

// Render thread groups table
function renderThreadGroupsTable() {
    const tbody = document.getElementById('threadGroupsTableBody');
    tbody.innerHTML = '';
    
    window.appState.threadGroupData.forEach((tg, index) => {
        const row = document.createElement('tr');
        row.className = tg.status ? '' : 'bg-gray-50';
        
        const statusClass = tg.status ? 'status-enabled' : 'status-disabled';
        const statusText = tg.status ? 'Enabled' : 'Disabled';
        
        row.innerHTML = `
            <td class="px-4 py-3">
                <span class="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium ${statusClass}">
                    ${statusText}
                </span>
            </td>
            <td class="px-4 py-3 text-sm font-medium text-gray-900">${escapeHtml(tg.name)}</td>
            <td class="px-4 py-3 text-center">
                <input type="number" 
                    id="users-${index}" 
                    value="${tg.count}" 
                    min="1" 
                    class="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-center">
            </td>
            <td class="px-4 py-3 text-center">
                <input type="number" 
                    id="rampup-${index}" 
                    value="${tg.rampTime}" 
                    min="0" 
                    class="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-center">
            </td>
            <td class="px-4 py-3 text-center">
                <input type="number" 
                    id="loop-${index}" 
                    value="${tg.loops}" 
                    min="-1" 
                    title="-1 for infinite loops"
                    class="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-center">
            </td>
            <td class="px-4 py-3 text-center">
                <input type="number" 
                    id="duration-${index}" 
                    value="${tg.duration}" 
                    min="0" 
                    title="0 for infinite duration"
                    class="w-20 px-2 py-1 text-sm border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 focus:border-blue-500 text-center">
            </td>
            <td class="px-4 py-3 text-center">
                <div class="flex items-center justify-center gap-2">
                    <button onclick="applyThreadGroupChanges(${index})" 
                        class="px-3 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700 transition-colors"
                        title="Apply changes">
                        Apply
                    </button>
                    <button onclick="toggleThreadGroupStatus(${index})" 
                        class="px-3 py-1 ${tg.status ? 'bg-yellow-600 hover:bg-yellow-700' : 'bg-green-600 hover:bg-green-700'} text-white text-xs rounded transition-colors"
                        title="${tg.status ? 'Disable' : 'Enable'} thread group">
                        ${tg.status ? 'üö´ Disable' : '‚úÖ Enable'}
                    </button>
                    <button onclick="deleteThreadGroup(${index})" 
                        class="px-3 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700 transition-colors"
                        title="Delete thread group">
                        üóëÔ∏è Delete
                    </button>
                </div>
            </td>
        `;
        
        tbody.appendChild(row);
    });
}

// Expose renderThreadGroupsTable as window function for external calls
window.renderThreadGroupsTable = renderThreadGroupsTable;

// Toggle thread group status (enable/disable)
function toggleThreadGroupStatus(index) {
    const tg = window.appState.threadGroupData[index];
    if (!tg) return;
    
    const newStatus = !tg.status;
    const action = newStatus ? 'enable' : 'disable';
    
    if (!confirm(`Are you sure you want to ${action} "${tg.name}"?`)) {
        return;
    }
    
    // Update XML
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(window.appState.jmxData, 'text/xml');
    const allThreadGroups = xmlDoc.querySelectorAll('ThreadGroup, com.blazemeter.jmeter.threads.concurrency.ConcurrencyThreadGroup, com.octoperf.jmeter.OctoPerfThreadGroup');
    
    if (index < allThreadGroups.length) {
        const tgElement = allThreadGroups[index];
        tgElement.setAttribute('enabled', newStatus.toString());
        
        // Serialize and update
        const serializer = new XMLSerializer();
        window.appState.jmxData = serializer.serializeToString(xmlDoc);
        
        // Update state
        window.appState.threadGroupData[index].status = newStatus;
        
        // Refresh displays
        renderThreadGroupsTable();
        updatePerformanceSummary();
        renderScalingTable();
        renderWorkloadTable();
        
        showToast(`Thread group "${tg.name}" ${action}d successfully`, 'success');
    }
}

// Delete thread group
function deleteThreadGroup(index) {
    const tg = window.appState.threadGroupData[index];
    if (!tg) return;
    
    if (!confirm(`‚ö†Ô∏è WARNING: This will permanently delete the thread group "${tg.name}" and all its samplers, timers, and configurations.\n\nThis action cannot be undone. Continue?`)) {
        return;
    }
    
    // Update XML - remove the thread group element
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(window.appState.jmxData, 'text/xml');
    const allThreadGroups = xmlDoc.querySelectorAll('ThreadGroup, com.blazemeter.jmeter.threads.concurrency.ConcurrencyThreadGroup, com.octoperf.jmeter.OctoPerfThreadGroup');
    
    if (index < allThreadGroups.length) {
        const tgElement = allThreadGroups[index];
        tgElement.parentNode.removeChild(tgElement);
        
        // Serialize and update
        const serializer = new XMLSerializer();
        window.appState.jmxData = serializer.serializeToString(xmlDoc);
        
        // Update state - remove from array
        window.appState.threadGroupData.splice(index, 1);
        window.appState.originalThreadGroupCounts.splice(index, 1);
        
        // Re-parse to update all related data
        const updatedDoc = parser.parseFromString(window.appState.jmxData, 'text/xml');
        window.appState.jmxDocument = updatedDoc;
        
        // Refresh all displays
        renderThreadGroupsTable();
        updatePerformanceSummary();
        renderSamplersTable();
        renderTimersTable();
        renderScalingTable();
        renderWorkloadTable();
        renderVariablesTable();
        renderCSVTable();
        
        showToast(`Thread group "${tg.name}" deleted successfully`, 'success');
    }
}

// Expose toggle and delete functions
window.toggleThreadGroupStatus = toggleThreadGroupStatus;
window.deleteThreadGroup = deleteThreadGroup;

// Apply thread group changes
window.applyThreadGroupChanges = function(index) {
    const tg = window.appState.threadGroupData[index];
    const newUsers = parseInt(document.getElementById(`users-${index}`).value);
    const newRampUp = parseInt(document.getElementById(`rampup-${index}`).value);
    const newLoop = parseInt(document.getElementById(`loop-${index}`).value);
    const newDuration = parseInt(document.getElementById(`duration-${index}`).value);
    
    if (isNaN(newUsers) || newUsers < 1) {
        showToast('Users must be at least 1', 'error');
        return;
    }
    
    if (isNaN(newRampUp) || newRampUp < 0) {
        showToast('Ramp-Up cannot be negative', 'error');
        return;
    }
    
    if (isNaN(newLoop) || newLoop < -1) {
        showToast('Loop Count must be -1 (infinite) or greater', 'error');
        return;
    }
    
    if (isNaN(newDuration) || newDuration < 0) {
        showToast('Duration cannot be negative', 'error');
        return;
    }
    
    // Update in memory
    tg.count = newUsers;
    tg.rampTime = newRampUp;
    tg.loops = newLoop.toString();
    tg.duration = newDuration;
    
    // Update in XML using the modifier functions
    const intProps = tg.element.getElementsByTagName("intProp");
    for (let i = 0; i < intProps.length; i++) {
        if (intProps[i].getAttribute("name") === "ThreadGroup.num_threads") {
            intProps[i].textContent = newUsers.toString();
            break;
        }
    }
    
    updateRampTimeInXML(tg.element, newRampUp);
    updateLoopCountInXML(tg.element, newLoop);
    updateDurationInXML(tg.element, newDuration);
    
    showToast(`Updated ${tg.name} successfully`, 'success');
    updatePerformanceSummary();
};

// Toast notification
window.showToast = function(message, type = 'info') {
    const toast = document.getElementById('toast');
    const toastMessage = document.getElementById('toastMessage');
    
    toastMessage.textContent = message;
    toast.className = "fixed bottom-4 right-4 text-white px-6 py-3 rounded-lg shadow-lg transform transition-transform duration-300";
    
    if (type === 'success') toast.className += ' bg-green-600';
    else if (type === 'error') toast.className += ' bg-red-600';
    else if (type === 'warning') toast.className += ' bg-yellow-600';
    else toast.className += ' bg-black';
    
    toast.style.transform = 'translateY(0)';
    toast.style.opacity = '1';
    
    setTimeout(() => {
        toast.style.transform = 'translateY(5rem)';
        toast.style.opacity = '0';
    }, 3000);
};

// HTML escape utility
function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Variables Manager Functions
window.showAddVariableModal = function() {
    document.getElementById('addVariableModal').classList.remove('hidden');
    document.getElementById('newVarName').value = '';
    document.getElementById('newVarValue').value = '';
    document.getElementById('newVarName').focus();
};

window.closeAddVariableModal = function() {
    document.getElementById('addVariableModal').classList.add('hidden');
};

window.confirmAddVariable = function() {
    const name = document.getElementById('newVarName').value.trim();
    const value = document.getElementById('newVarValue').value.trim();
    
    if (!name) {
        showToast('Variable name is required', 'error');
        return;
    }
    
    const result = addVar(name, value);
    if (result.success) {
        closeAddVariableModal();
        renderVariablesTable();
        showToast(`Added variable: ${name}`, 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.updateVariable = function(index) {
    const result = updateVar(index);
    if (result.success) {
        renderVariablesTable();
        showToast('Variable updated successfully', 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.deleteVariable = function(index) {
    if (!confirm('Are you sure you want to delete this variable?')) return;
    
    const result = deleteVar(index);
    if (result.success) {
        renderVariablesTable();
        showToast('Variable deleted successfully', 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.updateUDVGroupName = function() {
    const result = updateUDVGroupName();
    if (result.success) {
        showToast(result.message, 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.findAndReplaceVariables = function() {
    const findText = document.getElementById('findText').value;
    const replaceText = document.getElementById('replaceText').value;
    
    if (!findText) {
        showToast('Please enter text to find', 'error');
        return;
    }
    
    const result = findReplace(findText, replaceText);
    if (result.success) {
        renderVariablesTable();
        const resultDiv = document.getElementById('findReplaceResult');
        resultDiv.querySelector('p').textContent = `Replaced "${findText}" with "${replaceText}" in ${result.count} variable(s)`;
        resultDiv.classList.remove('hidden');
        showToast(`Updated ${result.count} variable(s)`, 'success');
        
        setTimeout(() => {
            resultDiv.classList.add('hidden');
        }, 5000);
    } else {
        showToast(result.error, 'error');
    }
};

window.previewFindReplace = function() {
    const findText = document.getElementById('findText').value;
    
    if (!findText) {
        showToast('Please enter text to find', 'error');
        return;
    }
    
    const result = previewFindReplace(findText);
    const resultDiv = document.getElementById('findReplaceResult');
    
    if (result.matches.length === 0) {
        resultDiv.querySelector('p').textContent = `No matches found for "${findText}"`;
        resultDiv.classList.remove('hidden');
    } else {
        const matchList = result.matches.map(m => `${m.name}: ${m.value}`).join(', ');
        resultDiv.querySelector('p').textContent = `Found ${result.matches.length} match(es): ${matchList}`;
        resultDiv.classList.remove('hidden');
    }
    
    setTimeout(() => {
        resultDiv.classList.add('hidden');
    }, 5000);
};

// Sampler Manager Functions
window.deleteSampler = function(index) {
    if (!confirm('Are you sure you want to delete this sampler?')) return;
    
    const result = delSampler(index);
    if (result.success) {
        renderSamplersTable();
        showToast('Sampler deleted successfully', 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.renameSampler = function(index) {
    const result = renameSamp(index);
    if (result.success) {
        showToast('Sampler renamed successfully', 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.renameAllSamplersAction = function() {
    const result = renameAllSamplers();
    if (result.success) {
        if (result.count === 0) {
            showToast('No changes to apply', 'info');
        } else {
            showToast(`${result.count} sampler(s) renamed successfully`, 'success');
        }
    } else {
        showToast(result.error, 'error');
    }
};
window.bulkDeleteSamplers = function() {
    const checkboxes = document.querySelectorAll('.sampler-checkbox:checked');
    if (checkboxes.length === 0) {
        showToast('Please select samplers to delete', 'error');
        return;
    }
    
    if (!confirm(`Delete ${checkboxes.length} selected sampler(s)?`)) return;
    
    const result = bulkDelSamplers();
    if (result.success) {
        document.getElementById('selectAllSamplers').checked = false;
        renderSamplersTable();
        showToast(`Deleted ${result.count} sampler(s)`, 'success');
    } else {
        showToast(result.error, 'error');
    }
};

window.filterSamplers = function() {
    const searchTerm = document.getElementById('samplerSearch').value;
    const filtered = filterSamplers(searchTerm);
    renderSamplersTable(filtered);
};

window.toggleAllSamplers = function() {
    const selectAll = document.getElementById('selectAllSamplers');
    const checkboxes = document.querySelectorAll('.sampler-checkbox');
    checkboxes.forEach(cb => cb.checked = selectAll.checked);
};

// Workload Calculator Functions
window.calculateUsersOnly = function(threadGroupIndex) {
    const result = calculateUsersOnly(threadGroupIndex);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    showToast(`Calculated ${result.users} users needed. Click "Apply All" to save.`, 'success');
};

window.calculateAndApplyUsers = function(threadGroupIndex) {
    // For backward compatibility - just calculate, don't apply
    window.calculateUsersOnly(threadGroupIndex);
};

window.calculateTPSForThreadGroup = function(threadGroupIndex) {
    const result = calcTPSForTG(threadGroupIndex);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    showToast(`Calculated TPS: ${result.tps.toFixed(2)}`, 'success');
};

window.calculatePacingForThreadGroup = function(threadGroupIndex) {
    const result = calcPacingForTG(threadGroupIndex);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    showToast(`Calculated Pacing: ${result.pacing.toFixed(2)}s`, 'success');
};

window.applyCalculatedValues = function(threadGroupIndex) {
    const result = applyCalculatedValues(threadGroupIndex);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderThreadGroupsTable();
    renderWorkloadTable();
    updatePerformanceSummary();
    showToast(`Applied ${result.users} users and ${result.tps.toFixed(2)} TPS`, 'success');
};

window.applyTPSToThreadGroup = function(threadGroupIndex) {
    // For backward compatibility - redirect to applyCalculatedValues
    window.applyCalculatedValues(threadGroupIndex);
};

// Timer Manager Functions
window.addTimer = function() {
    const type = document.getElementById('timerType').value;
    const name = document.getElementById('timerName').value.trim();
    const delay = parseInt(document.getElementById('timerDelay').value);
    const randomDelay = parseInt(document.getElementById('timerRandomDelay').value) || 0;
    const deviation = parseInt(document.getElementById('timerDeviation').value) || 0;
    
    if (!name) {
        showToast('Please enter a timer name', 'error');
        return;
    }
    
    if (isNaN(delay) || delay < 0) {
        showToast('Please enter a valid delay', 'error');
        return;
    }
    
    const result = addTmr(type, name, delay, randomDelay, deviation);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderTimersTable();
    if (result.addedCount > 1) {
        showToast(`${result.addedCount} timers added successfully`, 'success');
    } else {
        showToast(`Timer "${name}" added successfully`, 'success');
    }
    
    // Reset form
    document.getElementById('timerName').value = '';
    document.getElementById('timerDelay').value = '3000';
};

window.updateTimerSamplerList = updateTimerSamplerList;

window.deleteTimer = function(index) {
    if (!confirm('Are you sure you want to delete this timer?')) {
        return;
    }
    
    const result = delTimer(index);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderTimersTable();
    showToast('Timer deleted successfully', 'success');
};

window.toggleTimer = function(index) {
    const result = togTimer(index);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderTimersTable();
    const timer = window.appState.timers[index];
    showToast(`Timer ${timer.enabled ? 'enabled' : 'disabled'}`, 'success');
};

window.showBulkAddModal = function() {
    const delay = prompt('Enter think time delay (milliseconds):', '3000');
    if (!delay) return;
    
    const randomDelay = prompt('Enter random delay maximum (milliseconds, 0 for constant):', '1000');
    if (randomDelay === null) return;
    
    const delayNum = parseInt(delay);
    const randomDelayNum = parseInt(randomDelay);
    
    if (isNaN(delayNum) || delayNum < 0) {
        showToast('Invalid delay value', 'error');
        return;
    }
    
    if (isNaN(randomDelayNum) || randomDelayNum < 0) {
        showToast('Invalid random delay value', 'error');
        return;
    }
    
    const timerType = randomDelayNum > 0 ? 'UniformRandomTimer' : 'ConstantTimer';
    const result = bulkAddTT(delayNum, randomDelayNum, timerType);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderTimersTable();
    showToast(`Added think time to ${result.addedCount} samplers`, 'success');
};

// CSV Manager Functions
window.addCSVConfig = function() {
    const type = document.getElementById('csvType').value;
    const name = document.getElementById('csvName').value.trim();
    const filename = document.getElementById('csvFilePath').value.trim();
    const fileEncoding = document.getElementById('csvFileEncoding').value.trim();
    const variableNames = document.getElementById('csvVariables').value.trim();
    const delimiter = document.getElementById('csvDelimiter').value;
    
    if (!name) {
        showToast('Please enter a config name', 'error');
        return;
    }
    
    if (!filename) {
        showToast('Please enter a file path', 'error');
        return;
    }
    
    if (!variableNames) {
        showToast('Please enter variable names', 'error');
        return;
    }
    
    // Build config object based on type
    const config = {
        name,
        filename,
        fileEncoding,
        variableNames,
        delimiter
    };
    
    // Add type-specific fields
    if (type === 'CSVDataSet') {
        config.shareMode = document.getElementById('csvShareMode').value;
        config.recycle = document.getElementById('csvRecycle').checked;
        config.stopThread = document.getElementById('csvStopThread').checked;
        config.ignoreFirstLine = document.getElementById('csvIgnoreFirstLine').checked;
        config.allowQuoted = document.getElementById('csvAllowQuoted').checked;
    } else if (type === 'RandomCSVDataSet') {
        config.randomOrder = document.getElementById('csvRandomOrder').checked;
        config.rewind = document.getElementById('csvRewind').checked;
        config.firstLineHeader = document.getElementById('csvFirstLineHeader').checked;
        config.independentList = document.getElementById('csvIndependentList').checked;
    } else if (type === 'ExtendedCSVDataSet') {
        config.shareMode = document.getElementById('csvShareMode').value;
        config.ignoreFirstLine = document.getElementById('csvIgnoreFirstLine').checked;
        config.allowQuoted = document.getElementById('csvAllowQuoted').checked;
        config.selectRow = document.getElementById('csvSelectRow').value;
        config.updateValues = document.getElementById('csvUpdateValues').value;
        config.outOfValues = document.getElementById('csvOutOfValues').value;
        const allocateMode = document.querySelector('input[name="csvAllocateMode"]:checked').value;
        config.allocateMode = allocateMode;
        config.allocateCount = allocateMode === 'manual' ? parseInt(document.getElementById('csvAllocateCount').value) || 1 : 0;
    } else if (type === 'UniqueCSVDataSet') {
        config.shareMode = document.getElementById('csvShareMode').value;
        config.recycle = document.getElementById('csvRecycle').checked;
        config.stopThread = document.getElementById('csvStopThread').checked;
        config.ignoreFirstLine = document.getElementById('csvIgnoreFirstLine').checked;
        config.allowQuoted = document.getElementById('csvAllowQuoted').checked;
        config.targetThreadGroup = document.getElementById('csvTargetThreadGroup').value.trim();
        config.blockSize = parseInt(document.getElementById('csvBlockSize').value) || 1;
    }
    
    const result = addCSV(type, config);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderCSVTable();
    showToast(`CSV Config "${name}" added successfully`, 'success');
    
    // Reset form
    document.getElementById('csvName').value = '';
    document.getElementById('csvFilePath').value = '';
    document.getElementById('csvVariables').value = '';
    document.getElementById('csvFileEncoding').value = 'UTF-8';
    document.getElementById('csvDelimiter').value = ',';
    document.getElementById('csvAllocateAuto').checked = true;
    document.getElementById('csvAllocateCount').value = '1';
};

window.editCSVConfig = function(index) {
    const result = editCSV(index);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderCSVTable();
    showToast('Edit the config and click "Add CSV Config" to save changes', 'info');
};

window.deleteCSVConfig = function(index) {
    if (!confirm('Are you sure you want to delete this CSV config?')) {
        return;
    }
    
    const result = delCSV(index);
    
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    
    renderCSVTable();
    showToast('CSV config deleted successfully', 'success');
};

window.updateCSVTypeFields = function() {
    const type = document.getElementById('csvType').value;
    const shareModeSelect = document.getElementById('csvShareMode');
    
    // Hide all type-specific fields first
    document.getElementById('extendedSelectRow').classList.add('hidden');
    document.getElementById('extendedUpdateValues').classList.add('hidden');
    document.getElementById('extendedOutOfValues').classList.add('hidden');
    document.getElementById('extendedAllocateValues').classList.add('hidden');
    document.getElementById('uniqueThreadGroup').classList.add('hidden');
    document.getElementById('uniqueBlockSize').classList.add('hidden');
    document.getElementById('randomOrderCheck').classList.add('hidden');
    document.getElementById('rewindCheck').classList.add('hidden');
    document.getElementById('headerCheck').classList.add('hidden');
    document.getElementById('independentCheck').classList.add('hidden');
    document.getElementById('recycleCheck').classList.add('hidden');
    document.getElementById('stopThreadCheck').classList.add('hidden');
    document.getElementById('ignoreFirstLineCheck').classList.add('hidden');
    document.getElementById('allowQuotedCheck').classList.add('hidden');
    
    // Update sharing mode options based on type
    if (type === 'CSVDataSet') {
        // Standard: All threads, Current thread group, Current thread
        shareModeSelect.innerHTML = `
            <option value="shareMode.all">All threads</option>
            <option value="shareMode.group">Current thread group</option>
            <option value="shareMode.thread">Current thread</option>
        `;
        // Show Standard CSV checkboxes
        document.getElementById('recycleCheck').classList.remove('hidden');
        document.getElementById('stopThreadCheck').classList.remove('hidden');
        document.getElementById('ignoreFirstLineCheck').classList.remove('hidden');
        document.getElementById('allowQuotedCheck').classList.remove('hidden');
    } else if (type === 'RandomCSVDataSet') {
        // Random: All threads, Current thread group, Current thread
        shareModeSelect.innerHTML = `
            <option value="shareMode.all">All threads</option>
            <option value="shareMode.group">Current thread group</option>
            <option value="shareMode.thread">Current thread</option>
        `;
        // Show Random CSV specific checkboxes
        document.getElementById('randomOrderCheck').classList.remove('hidden');
        document.getElementById('rewindCheck').classList.remove('hidden');
        document.getElementById('headerCheck').classList.remove('hidden');
        document.getElementById('independentCheck').classList.remove('hidden');
    } else if (type === 'ExtendedCSVDataSet') {
        // Extended: All threads, Current thread group, Current thread
        shareModeSelect.innerHTML = `
            <option value="shareMode.all">All threads</option>
            <option value="shareMode.group">Current thread group</option>
            <option value="shareMode.thread">Current thread</option>
        `;
        // Show Extended-specific fields
        document.getElementById('extendedSelectRow').classList.remove('hidden');
        document.getElementById('extendedUpdateValues').classList.remove('hidden');
        document.getElementById('extendedOutOfValues').classList.remove('hidden');
        document.getElementById('extendedAllocateValues').classList.remove('hidden');
        document.getElementById('ignoreFirstLineCheck').classList.remove('hidden');
        document.getElementById('allowQuotedCheck').classList.remove('hidden');
        // Trigger extended field behavior
        window.updateExtendedFields();
    } else if (type === 'UniqueCSVDataSet') {
        // Unique: All threads, Current thread group, Current thread, Target thread, Edit
        shareModeSelect.innerHTML = `
            <option value="shareMode.all">All threads</option>
            <option value="shareMode.group">Current thread group</option>
            <option value="shareMode.thread">Current thread</option>
            <option value="shareMode.target">Target thread</option>
            <option value="shareMode.edit">Edit</option>
        `;
        // Show Unique-specific fields
        document.getElementById('uniqueThreadGroup').classList.remove('hidden');
        document.getElementById('uniqueBlockSize').classList.remove('hidden');
        document.getElementById('recycleCheck').classList.remove('hidden');
        document.getElementById('stopThreadCheck').classList.remove('hidden');
        document.getElementById('ignoreFirstLineCheck').classList.remove('hidden');
        document.getElementById('allowQuotedCheck').classList.remove('hidden');
    }
};

window.updateExtendedFields = function() {
    const selectRow = document.getElementById('csvSelectRow').value;
    const outOfValuesSelect = document.getElementById('csvOutOfValues');
    const allocateSection = document.getElementById('extendedAllocateValues');
    
    if (selectRow === 'Random') {
        // Disable "When out of Values" and set to "Continue Cyclic"
        outOfValuesSelect.disabled = true;
        outOfValuesSelect.value = 'Continue Cyclic';
        allocateSection.classList.add('hidden');
    } else if (selectRow === 'Unique') {
        // Enable "When out of Values"
        outOfValuesSelect.disabled = false;
        // Show allocate values section
        allocateSection.classList.remove('hidden');
    } else { // Sequential
        // Enable "When out of Values"
        outOfValuesSelect.disabled = false;
        allocateSection.classList.add('hidden');
    }
};

// Timer type change handler
document.addEventListener('DOMContentLoaded', function() {
    const timerTypeSelect = document.getElementById('timerType');
    if (timerTypeSelect) {
        timerTypeSelect.addEventListener('change', function() {
            const type = this.value;
            const additionalOptions = document.getElementById('timerAdditionalOptions');
            
            if (type === 'UniformRandomTimer' || type === 'GaussianRandomTimer') {
                additionalOptions.classList.remove('hidden');
            } else {
                additionalOptions.classList.add('hidden');
            }
        });
    }
});

// Master Controller Functions
window.updatePerformanceSummary = updatePerformanceSummary;
window.renderScalingTable = renderScalingTable;
window.renderWorkloadTable = renderWorkloadTable;
window.setMasterScale = setMasterScale;
window.applyMasterScale = function() {
    const result = applyMasterScaling();
    if (!result.success) {
        showToast(result.error, 'error');
        return;
    }
    renderThreadGroupsTable();
    updatePerformanceSummary();
    showToast(`Applied master scale successfully!`, 'success');
};

// Workload Calculator Mode Switcher
window.switchWorkloadMode = function(mode) {
    const scalingCalc = document.getElementById('scaling-calculator');
    const littlesCalc = document.getElementById('littles-calculator');
    const scalingBtn = document.getElementById('btn-scaling-mode');
    const littlesBtn = document.getElementById('btn-littles-mode');
    
    if (mode === 'scaling') {
        scalingCalc.style.display = 'block';
        littlesCalc.style.display = 'none';
        scalingBtn.className = 'flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-blue-600 text-white';
        littlesBtn.className = 'flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-gray-200 text-gray-700 hover:bg-gray-300';
    } else {
        scalingCalc.style.display = 'none';
        littlesCalc.style.display = 'block';
        scalingBtn.className = 'flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-gray-200 text-gray-700 hover:bg-gray-300';
        littlesBtn.className = 'flex-1 px-6 py-3 text-sm font-medium rounded-lg transition-colors bg-blue-600 text-white';
    }
};

// TPS Scaling Calculator Functions
window.calculateScalingFactor = calculateScalingFactor;
window.applyScaledValues = applyScaledValues;
window.calculateAndApplyIndividualTPS = calculateAndApplyIndividualTPS;

// Initialize
console.log('JMX Studio v4.0.0 initialized');



    </script>
</body>
</html>
